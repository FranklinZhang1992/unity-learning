#!/usr/bin/ruby

#
# Examples:
# 1) Scan a specified folder
#   application_scanner scan --location=/tmp/scan_dir -v
#
# 2) Export the latest unqualified record to a directory
#   application_scanner export --output-format=raw --output-type=file --output-location=/tmp -v
#
# 3) Import an edited record
#   application_scanner import --location=/tmp/20170924215208 -v
#
# 4) Check a specified folder
#   application_scanner check --location=/tmp/check_dir -v
#

require 'logger'
require 'optparse'
require 'singleton'
require 'fileutils'
require 'set'
require 'tempfile'
require 'json'
require 'rexml/document'

$stdout.sync = true
$verbose = false

module Process
    class Status
        def describe
            str = ''
            if signaled?
                str << 'signal ' << termsig.to_s
            elsif success?
                str << 'success'
            else
                str << 'exit ' << exitstatus.to_s
            end
            str << ' (with core)' if coredump?
            str
        end
    end
end

class Logger
    class Formatter
        def timestamp(time)
            time.strftime('%m/%d %H:%M:%S.') + ('%06d' % [time.usec.to_s])
        end
        def call(severity, time, progname, message)
            "%s %s %s\n" % [severity[0..0], timestamp(time), message]
        end
    end
end

def log
    $logger ||= begin
        if $logfile
            dir = File.dirname($logfile)
            FileUtils.mkdir_p(dir)
            Logger.new($logfile)
        else
            Logger.new(STDOUT)
        end
    end
    $logger.level = $verbose ? Logger::DEBUG : Logger::INFO
    $logger
end

def print(msg)
    puts msg
end

def cook_line(raw_line)
    return nil if raw_line.nil?
    cooked_line = raw_line.lstrip.rstrip
    return nil if cooked_line.empty?
    cooked_line
end

def trap_exit
    ['HUP', 'QUIT', 'INT', 'TERM'].each do |signal|
        trap(signal) { raise SystemExit.new(signal) }
    end
end

def quit(signal)
    $logger.close unless $logger.nil?
    exit(signal)
end

#
# Execute system command and log the command
#
def exec_sys_cmd(cmd)
    log.debug(">> #{cmd}")
    output = %x{#{cmd} 2>&1}
    raise CommandError, "#{cmd} failed, #{$?.describe}, #{output.strip}" unless $?.success?
end

class BaseError < RuntimeError ; end
class RecordError < BaseError; end
class CheckResultError < BaseError; end
class StorageEngineError < BaseError ; end
class FileMergerError < BaseError ; end
class MainControllerError < BaseError ; end
class CommandError < BaseError ; end

class Object
    def standard_timetamp(time=nil)
        time = Time.now if time.nil?
        time.strftime("%Y%m%d%H%M%S")
    end
end

class Module

    def artifact
        class << self
            def properties() const_get(:RecordProperties).clone rescue Set.new end
        end
        define_method(:id) {
            id = instance_variable_get("@id")
            if id.nil?
                id = standard_timetamp
                instance_variable_set("@id", id)
            end
            id
        }
        define_method(:topology) {
            topo = Hash.new
            self.class.properties.each do |property|
                value = self.instance_variable_get("@#{property}")
                topo[property.to_sym] = value
            end
            topo
        }

    end
    def property(*symbols)
        symbols.each do |symbol|
            property_cfg(symbol)
        end
    end

    def property_cfg(symbol)
        properties = Set.new
        begin
            properties = const_get(:RecordProperties)
        rescue NameError
            properties = Set.new
        end
        unless const_defined?(:RecordProperties)
            const_set(:RecordProperties, properties)
        end
        properties << symbol.to_sym

        define_method(symbol) {
            instance_variable_get("@#{symbol}")
        }

        define_method("#{symbol}=") { |value|
            instance_variable_set("@#{symbol}", value)
        }
    end
end

class Record

    include REXML

    artifact

    property :whitelist
    property :blacklist
    property :auditor
    property :qual # true for qualified and false for unqualified

    def initialize
        self.qual = false
    end

    def qualified?
        return qual == "true"
    end

    def whitelist_array
        self.whitelist.split("\n")
    rescue
        []
    end

    def blacklist_array
        self.blacklist.split("\n")
    rescue
        []
    end

    def to_xml
        xml = Element.new("Record")
        xml.attributes["id"] = self.id
        topology.each do |key, value|
            xml << Element.new("#{key}").add_text("#{value}")
        end
        xml
    end

    def to_json
        record_hash = topology.clone
        record_hash[:id] = self.id
        JSON.generate(record_hash)
    end

    def to_s
        str = "Record id=#{self.id}\n"
        topology.each do |key, value|
            str << "  #{key}:\n"
            value_array = begin value.split("\n") rescue [] end
            value_array.each do |v|
                str << "    #{v}\n"
            end
        end
        str
    end
end

class CheckResult

    include REXML

    attr :fname
    attr :blacklist_app_list
    attr :unqual_app_list

    def initialize(fname)
        @fname = fname
        @blacklist_app_list = []
        @unqual_app_list = []
    end

    def push_to_blacklist_app_list(app)
        @blacklist_app_list << app unless app.nil?
    end

    def push_to_unqual_app_list(app)
        @unqual_app_list << app unless app.nil?
    end

    def blacklist_app_list
        @blacklist_app_list.nil? ? [] : @blacklist_app_list
    end

    def blacklist_app_list=(value)
        raise CheckResultError, "Only array is accepted" unless !value.nil? and value.is_a? Array
        @blacklist_app_list = value
    end

    def unqual_app_list
        @unqual_app_list.nil? ? [] : @unqual_app_list
    end

    def unqual_app_list=(value)
        raise CheckResultError, "Only array is accepted" unless !value.nil? and value.is_a? Array
        @unqual_app_list = value
    end

    def to_xml
        xml = Element.new("CheckResult")
        xml.attributes["file-name"] = self.fname
        blacklist_app_xml = Element.new("blacklist-application")
        blacklist_app_list.each do |blacklist_app|
            blacklist_app_xml << Element.new("application").add_text(blacklist_app)
        end
        xml << blacklist_app_xml
        unqual_app_xml = Element.new("unqualified-application")
        unqual_app_list.each do |unqual_app|
            unqual_app_xml << Element.new("application").add_text(unqual_app)
        end
        xml << unqual_app_xml
        xml
    end

    def to_json
        result_hash = Hash.new
        result_hash["file-name"] = self.fname
        result_hash["blacklist-application"] = blacklist_app_list
        result_hash["unqualified-application"] = unqual_app_list
        JSON.generate(result_hash)
    end

    def to_s
        str = "File: #{self.fname}\n"
        str << "  Blacklist application:\n" unless blacklist_app_list.empty?
        blacklist_app_list.each do |blacklist_app|
            str << "    #{blacklist_app}\n"
        end
        str << "  Unqualified application:\n" unless unqual_app_list.empty?
        unqual_app_list.each do |unqual_app|
            str << "    #{unqual_app}\n"
        end
        str
    end
end

class StorageEngine

    DEFAULT_POOL = "/tmp/appsanner_pool"

    attr :pool

    def initialize(pool)
        if pool.nil?
            pool = DEFAULT_POOL
            setup_pool(pool)
        else
            setup_pool(pool)
        end
        log.debug("Initialize storage engine wiht pool #{pool}")
        @pool = pool
    end

    def setup_pool(dir)
        unless File.exist?(dir)
            log.debug("Initializing storage pool")
            exec_sys_cmd("mkdir -p #{dir}")
        end
    end

    def absolute_path(path)
        raise StorageEngineError, "path is nil" if path.nil?
        raise StorageEngineError, "path is an empty string" if path.to_s.length == 0
        File.join(self.pool, path)
    end 

    def rename(oldpath, newpath)
        File.rename(absolute_path(oldpath), absolute_path(newpath))
    end

    def store_property(object, property, dir)
        value = object.instance_variable_get("@#{property}")
        path = "#{dir}/#{property}"
        temp_file = Tempfile.open("#{property}", absolute_path(dir))
        begin
            temp_file.puts value
            temp_file.flush
            FileUtils.cp(temp_file.path, absolute_path(path))
        ensure
            temp_file.close!
        end
    end

    def load_property(object, property)
        path = absolute_path("#{object.id}/#{property}")
        old_value = object.instance_variable_get("@#{property}")
        value = begin IO.read(path).chomp rescue nil end
        object.instance_variable_set("@#{property}", value)
    end

    def record_exist?(id)
        !id.nil? && File.exist?(absolute_path(id))
    end

    def inspect(id)
        record = get_by_id(id)
        raise StorageEngineError, "Failed to inspect, no record found by id #{id}" if record.nil?
        print(record.to_s)
    end

    def inspect_all
        records = get_all
        records.each do |record|
            print(record.to_s)
        end
    end

    def get_by_id(id)
        return nil if id.nil?

        record = nil
        if record_exist?(id)
            record = Record.new
            record.instance_variable_set("@id", id)
            record.class.properties.each do |property|
                load_property(record, property)
            end
        end
        record
    end

    def get_all
        records = []
        Dir.glob(File.join(self.pool, "*")) do |dir|
            next unless File.directory?(dir)
            next if /\.TMP/ =~ dir
            id = File.basename(dir)
            record = get_by_id(id)
            records << record unless record.nil?
        end
        records
    end

    def create(record)
        log.debug("Creating directory for storing the record #{record.id}")

        tmp_dir = "#{record.id}.TMP"
        # Create a temp folder for the new record
        FileUtils.mkdir_p(absolute_path(tmp_dir))

        record.class.properties.each do |property|
            store_property(record, property, tmp_dir)
        end

        # Rename the temp folder to its real name
        rename(tmp_dir, record.id)

        record
    rescue
        tmp_dir_abs_path = absolute_path(tmp_dir)
        FileUtils.rm_rf(tmp_dir_abs_path) if File.exist?(tmp_dir_abs_path)
        raise
    end

    def update(record)
        raise StorageEngineError, "Cannot update a nil record" if record.nil?
        old_record = get_by_id(record.id)
        raise StorageEngineError, "No record found by id #{record.id}" if old_record.nil?
        old_record.class.properties.each do |property|
            next if old_record.instance_variable_get("@#{property}") == record.instance_variable_get("@#{property}")
            store_property(record, property, record.id)
        end
        record
    end

    def delete(id)
        abs_path = absolute_path(id)
        FileUtils.rm_rf(abs_path) if File.exist?(abs_path)
    end
end

class FileMerger

    DEFAULT_IGNORE_LINE_NUM = 1

    attr :base_content

    def initialize(old_base=nil)
        if old_base.nil?
            @base_content = Set.new
        else
            @base_content = Set.new(old_base.split("\n"))
        end
    end

    def push(content)
        @base_content << content
    end

    def include?(content)
        self.base_content.include?(content)
    end

    def load(file, ignore_line_num=DEFAULT_IGNORE_LINE_NUM)
        raise FileMergerError, "Cannot load a non-exist file #{file}" unless !file.nil? && File.exist?(file)
        line_num = 0
        File.open(file, 'r') do |f|
            while line = f.gets
                line_num += 1
                next unless line_num > ignore_line_num
                cooked_line = cook_line(line)
                next if cooked_line.nil? || include?(cooked_line)
                push(cooked_line)
            end
        end
    end

    def inspect
        base_content.to_a.join("\n")
    end
end

class MainController

    attr :config
    def initialize(config)
        init_config(config)

        @auditor = self.config[:auditor]
        @location = self.config[:location] # Used for import/scan
        @export_qual = self.config[:export_qual]
        @export_latest = self.config[:export_latest]
        @show_qual = self.config[:show_qual]
        @show_latest = self.config[:show_latest]
        @output_format = self.config[:output_format]
        @output_type = self.config[:output_type]
        @output_location = self.config[:output_location]
        @record_id = self.config[:record_id]
        @storage_engine = StorageEngine.new(self.config[:storage_pool])
    end

    def location_validation(location)
        raise MainControllerError, "Specified location #{location} does not exist" unless !location.nil? && File.exist?(location)
        raise MainControllerError, "Specified location is not a directory" unless File.directory?(location)
    end

    def output_format_validation(output_format)
        ["raw", "xml", "json"].include?(output_format) or raise MainControllerError, "Unsupported output format: #{output_format}"
    end

    def output_location_validation(output_location)
        raise MainControllerError, "Output location #{output} does not exist" unless !output_location.nil? && File.exist?(output_location)
    end

    def output_type_validation(output_type)
        ["stdout", "file"].include?(output_type) or raise MainControllerError, "Unsupported output type: #{output_type}"
    end

    def init_config(config)
        @config = config.nil? ? {} : config

        # Set default values
        self.config[:export_qual] = false if self.config[:export_qual].nil?
        self.config[:export_latest] = true if self.config[:export_latest].nil?
        self.config[:show_qual] = false if self.config[:show_qual].nil?
        self.config[:show_latest] = true if self.config[:show_latest].nil?
        self.config[:output_type] = "stdout" if self.config[:output_type].nil?
        self.config[:output_format] = "raw" if self.config[:output_format].nil?
        self.config[:auditor] = %x{whoami}.chomp if self.config[:auditor].nil?

        # Validate for each of the configurations
        self.config.each do |key, value|
            validation_method = "#{value}_validation"
            self.send(validation_method, self.config[key.to_sym]) if self.respond_to?(validation_method)
        end
    end

    def storage_engine() @storage_engine end

    def print_record_handler
        handler = "print_record_in_#{@output_format}_format"
        if self.respond_to?(handler)
            return handler
        else
            raise MainControllerError, "Unimplemented output format #{@output_format}"
        end
    end

    def write_record_handler
        handler = "write_record_in_#{@output_format}_format"
        if self.respond_to?(handler)
            return handler
        else
            raise MainControllerError, "Unimplemented output format #{@output_format}"
        end
    end

    def output_record_to_type_handler
        handler = "output_record_to_#{@output_type}"
        if self.respond_to?(handler)
            return handler
        else
            raise MainControllerError, "Unimplemented output type #{@output_type}"
        end
    end

    def get_unqual_records
        records = storage_engine.get_all
        qual_records = []
        records.each do |record|
            qual_records << record unless record.qualified?
        end
        qual_records
    end

    def get_qual_records
        records = storage_engine.get_all
        qual_records = []
        records.each do |record|
            qual_records << record if record.qualified?
        end
        qual_records
    end

    def sort_records(raw_records)
        records = raw_records.clone
        return records if records.size < 2
        (records.size - 2).downto(0) do |i|
            (0 .. i).each do |j|
                records[j], records[j + 1] = records[j + 1], records[j] if records[j].id.to_i < records[j + 1].id.to_i
            end
        end
        records
    end

    def write_to_file(path, content)
        File.open(path, "w+") do |f|
            f.puts content
        end
    end

    def read_file(path)
        content = ""
        File.open(path, "r") do |f|
            while line = f.gets
                cooked_line = cook_line(line)
                next if cooked_line.nil?
                content << line
            end
        end
        content
    end

    def output_record_to_stdout(record)
        self.send(print_record_handler, record)
    end

    def output_record_to_file(record)
        self.send(write_record_handler, record)
    end

    def write_record_in_xml_format(record)
        path = "#{@output_location}/#{record.id}"
        write_to_file(path, record.to_xml)
        log.info("Record has been written to #{path}")
    end

    def write_record_in_json_format(record)
        path = "#{@output_location}/#{record.id}"
        write_to_file(path, record.to_json)
        log.info("Record has been written to #{path}")
    end

    def write_record_in_raw_format(record)
        path = "#{@output_location}/#{record.id}"
        exec_sys_cmd("mkdir -p #{path}")
        write_to_file("#{path}/whitelist", record.whitelist)
        write_to_file("#{path}/blacklist", record.blacklist)
        log.info("Record has been written to #{path}")
    end

    def print_record_in_xml_format(record)
        print(record.to_xml)
    end

    def print_record_in_json_format(record)
        print(record.to_json)
    end

    def print_record_in_raw_format(record)
        print(record.to_s)
    end

    def output_record(record)
        raise MainControllerError, "Cannot output a non-exist record" if record.nil?
        self.send(output_record_to_type_handler, record)
    end

    def export_unqual_record
        records = sort_records(get_unqual_records)
        if @export_latest
            output_record(records.shift)
        else
            records.each do |record|
                output_record(record)
            end
        end
    end

    def export_qual_record
        records = sort_records(get_qual_records)
        if @export_latest
            output_record(records.shift)
        else
            records.each do |record|
                output_record(record)
            end
        end
    end

    def export
        if @output_type == "stdout"
            log.debug("Exporting to stdout in #{@output_format} format")
        else
            log.debug("Exporting to #{@output_location} in #{@output_format} format through #{@output_type}")
        end
        if @export_qual
            export_qual_record
        else
            export_unqual_record
        end
    end

    def scan
        log.debug("Scanning #{@location}")
        file_list = []
        Dir.glob(File.join(@location, "*")) do |file|
            next unless File.file?(file)
            file_list << file
        end
        latest_qual_record = sort_records(get_qual_records).shift
        latest_whitelist = latest_qual_record.nil? ? nil : latest_qual_record.whitelist
        latest_blacklist = latest_qual_record.nil? ? nil : latest_qual_record.blacklist
        file_merger = FileMerger.new(latest_whitelist)
        file_list.each do |file|
            file_merger.load(file)
        end
        record = Record.new
        record.whitelist = file_merger.inspect
        record.blacklist = latest_blacklist
        record.auditor = @auditor
        storage_engine.create(record)
        log.info("#{@location} has been scanned")
    end

    def import
        log.debug("Importing from #{@location}")
        id = File.basename(@location)
        record = storage_engine.get_by_id(id)
        raise MainControllerError, "Cannot import a non-exist record" if record.nil?
        record.whitelist = read_file("#{@location}/whitelist")
        record.blacklist = read_file("#{@location}/blacklist")
        record.qual = "true"
        record.auditor = @auditor
        storage_engine.update(record)
        log.info("Qualified record #{id} has been successfully imported")
    end

    def judge_file(file, whitelist, blacklist)
        file_content_array = begin IO.read(file).chomp.split("\n") rescue [] end
        check_result = CheckResult.new(File.basename(file))
        line_num = 0
        file_content_array.each do |content_line|
            line_num += 1
            cooked_line = cook_line(content_line)
            next if cooked_line.nil? || line_num <= 1 # Ignore the first line (The first line is the column name) and empty line
            next if whitelist.include?(cooked_line)
            if blacklist.include?(cooked_line)
                check_result.push_to_blacklist_app_list(cooked_line)
            else
                check_result.push_to_unqual_app_list(cooked_line)
            end
        end

        unless check_result.blacklist_app_list.empty? && check_result.unqual_app_list.empty?
            output_check_result(check_result)
        end
    end

    def check
        log.debug("Checking #{@location}")
        record = sort_records(get_qual_records).shift
        whitelist = record.whitelist_array
        blacklist = record.blacklist_array

        Dir.glob(File.join(@location, "*")) do |file|
            next unless File.file?(file)
            judge_file(file, whitelist, blacklist)
        end
        log.info("All files under #{@location} has been checked")
    end

    def output_check_result_to_type_handler
        handler = "output_check_result_to_#{@output_type}"
        if self.respond_to?(handler)
            return handler
        else
            raise MainControllerError, "Unimplemented output type #{@output_type}"
        end
    end

    def print_check_result_handler
        handler = "print_check_result_in_#{@output_format}_format"
        if self.respond_to?(handler)
            return handler
        else
            raise MainControllerError, "Unimplemented output format #{@output_format}"
        end
    end

    def write_check_result_handler
        handler = "write_check_result_in_#{@output_format}_format"
        if self.respond_to?(handler)
            return handler
        else
            raise MainControllerError, "Unimplemented output format #{@output_format}"
        end
    end

    def output_check_result(check_result)
        self.send(output_check_result_to_type_handler, check_result)
    end

    def output_check_result_to_file(check_result)
        self.send(write_check_result_handler, check_result)
    end

    def output_check_result_to_stdout(check_result)
        self.send(print_check_result_handler, check_result)
    end

    def print_check_result_in_xml_format(check_result)
        print(check_result.to_xml)
    end

    def print_check_result_in_json_format(check_result)
        print(check_result.to_json)
    end

    def print_check_result_in_raw_format(check_result)
        print(check_result.to_s)
    end

    def write_check_result_in_xml_format(check_result)
        path = "#{@output_location}/#{check_result.fname}"
        write_to_file(path, check_result.to_xml)
        log.info("Check result has been written to #{path}")
    end

    def write_check_result_in_json_format(check_result)
        path = "#{@output_location}/#{check_result.fname}"
        write_to_file(path, check_result.to_json)
        log.info("Check result has been written to #{path}")
    end

    def write_check_result_in_raw_format(check_result)
        path = "#{@output_location}/#{check_result.fname}"
        write_to_file(path, check_result.to_s)
        log.info("Check result has been written to #{path}")
    end

    def show
        if @show_qual
            show_qual_record
        else
            show_unqual_record
        end
    end

    def show_qual_record
        records = sort_records(get_qual_records)
        if @show_latest
            latest_record = records.shift
            unless latest_record.nil?
                print(latest_record.id)
            end
        else
            records.each do |record|
                print(latest_record.id)
            end
        end
    end

    def show_unqual_record
        records = sort_records(get_unqual_records)
        if @show_latest
            latest_record = records.shift
            unless latest_record.nil?
                print(latest_record.id)
            end
        else
            records.each do |record|
                print(latest_record.id)
            end
        end
    end

    def delete
        log.debug("Deleting record #{@record_id}")
        storage_engine.delete(@record_id)
        log.info("Record #{@record_id} has been deleted")
    end
end

class CommandHandler
    include Singleton
    attr :cmd_name

    def initialize
        @options = {}
        @cmd_name = "application_scanner"
    end

    def parse(args)
        return if args.nil? || args.empty?

        global_help = "Usage: #{self.cmd_name} COMMAND [options]\n"
        sub_help = "List of Commands:\n\n"
        sub_help << "import:        Import an edited record, thie record will be marked as qualified after import\n"
        sub_help << "export:        Export record to a specified location for editing\n"
        sub_help << "scan:          Scan a specified directory and create a new record with both old and delta content\n"
        sub_help << "check:         Check a specified directory to find if there are invalid applications\n"
        sub_help << "show:          Show stored record\n"
        sub_help << "delete:        Delete a specified record\n"
        sub_help << "\nSee '#{self.cmd_name} COMMAND --help' for more information on a specific command\n"

        global = OptionParser.new do |opts|
            opts.banner = global_help
            opts.separator ""
            opts.separator sub_help
        end

        def common_options(&blk)
            OptionParser.new do |opts|
                opts.on("-p", "--pool=POOL", "Specify the storage pool for all records (default is /tmp/appsanner_pool)") do |value|
                    @options[:storage_pool] = value
                end
                opts.on("-v", "--[no-]verbose", "Run verbosely") do |value|
                    $verbose = value
                end
                opts.on("-l", "--log=LOG_FILE", "Print logs to file instead of STDOUT") do |value|
                    $logfile = value
                end
                blk.call(opts)
            end
        end

        sub_commands = {
            "import" => common_options do |opts|
                opts.banner = "Usage: import [options]"
                opts.on("-l", "--location=LOCATION", "Specify the import location") do |value|
                    @options[:location] = value
                end
                opts.on("-a", "--auditor=AUDITOR", "Specify the auditor (default is your login username)") do |value|
                    @options[:auditor] = value
                end
            end,
            "export" => common_options do |opts|
                opts.banner = "Usage: export [options]"
                opts.on("--output-format=OUTPUTFORMAT", "Specify the output format [raw, json, xml] (default is raw)") do |value|
                    @options[:output_format] = value
                end
                opts.on("--output-type=OUTPUTTYPE", "Specify the output type [stdout, file] (default is stdout)") do |value|
                    @options[:output_type] = value
                end
                opts.on("--output-location=OUTPUTLOCATION", "Specify the output location") do |value|
                    @options[:output_location] = value
                end
                opts.on("-q", "--[no-]qual", "Only export the qualified record (default is false)") do |value|
                    @options[:export_qual] = value
                end
                opts.on("-l", "--[no-]latest", "Only export the latest record (default is true)") do |value|
                    @options[:export_latest] = value
                end
            end,
            "scan" => common_options do |opts|
                opts.banner = "Usage: scan [options]"
                opts.on("-l", "--location=LOCATION", "Specify the scan location") do |value|
                    @options[:location] = value
                end
                opts.on("-a", "--auditor=AUDITOR", "Specify the auditor (default is your login username)") do |value|
                    @options[:auditor] = value
                end
            end,
            "check" => common_options do |opts|
                opts.banner = "Usage: check [options]"
                opts.on("-l", "--location=LOCATION", "Specify the check location") do |value|
                    @options[:location] = value
                end
                opts.on("--output-format=OUTPUTFORMAT", "Specify the output format [raw, json, xml] (default is raw)") do |value|
                    @options[:output_format] = value
                end
                opts.on("--output-type=OUTPUTTYPE", "Specify the output type [stdout, file] (default is stdout)") do |value|
                    @options[:output_type] = value
                end
                opts.on("--output-location=OUTPUTLOCATION", "Specify the output location") do |value|
                    @options[:output_location] = value
                end
            end,
            "show" => common_options do |opts|
                opts.banner = "Usage: show [options]"
                opts.on("-q", "--[no-]qual", "Only show the qualified record (default is false)") do |value|
                    @options[:show_qual] = value
                end
                opts.on("-l", "--[no-]latest", "Only show the latest record (default is true)") do |value|
                    @options[:show_latest] = value
                end
            end,
            "delete" => common_options do |opts|
                opts.banner = "Usage: delete [options]"
                opts.on("-i", "--id=ID", "Specify the id of a record") do |value|
                    @options[:record_id] = value
                end
            end
        }

        global.order!
        command = args.shift
        sub_cmd = sub_commands[command]
        if sub_cmd.nil?
            raise CommandError, "No such command: #{command}. Please use '#{self.cmd_name} --help'"
        else
            sub_cmd.order!
        end

        @options[:command] = command
        @options
    end

    def handle(options)
        options = options.nil? ? {} : options
        controller = MainController.new(options)
        sub_cmd = @options[:command]
        raise CommandError, "No implmentation for command #{sub_cmd}" unless controller.respond_to?(sub_cmd)
        controller.send(sub_cmd)
    end
end

if __FILE__ == $0
    begin
        trap_exit
        options = CommandHandler.instance.parse(ARGV)
        CommandHandler.instance.handle(options)
    rescue SystemExit => err
        quit(0)
    rescue OptionParser::InvalidOption => err
        log.error("#{err}")
        quit(1)
    rescue BaseError => err
        log.error("#{err}")
        quit(2)
    rescue Exception => err
        log.error("#{err} (#{err.class})\n#{err.backtrace.join("\n\tfrom ")}")
        quit(3)
    else
        quit(0)
    end
end
