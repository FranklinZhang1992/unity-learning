#!/usr/bin/ruby

require 'readline'
require 'net/http'
require 'uri'
require 'rexml/document'

#=============================================================================

# Use example:
# ./dut_searcher
# > help
#=============================================================================

# This script is used to search for a DUT you need.

#=============================================================================

include REXML

class String
  def to_bool
    return true if self =~ (/^(true|t|yes|y|1)$/i)
    return false if self.empty? || self =~ (/^(false|f|no|n|0)$/i)

    raise ArgumentError.new "invalid value: #{self}"
  end
end

class Commands
  WIN_2K12_REGEXP = Regexp.new('win\S*2[0-9a-zA-Z]{0,}12')
  VALID_VERSION_REGEXP = Regexp.new('[0-9][.][0-9]')
  VALID_BUILD_NUM_REGEXP = Regexp.new('[0-9]{1,}')
  DUT_VERSION_REGEXP = Regexp.new('([0-9]{1,})[.]([0-9]{1,})[.][0-9]{1,}[-]([0-9]{1,})')
  INPUT_VERSION_REGEXP = Regexp.new('([0-9]{1,})[.]([0-9]{1,})')
  def win2k12_re() WIN_2K12_REGEXP end
  def valid_version_re() VALID_VERSION_REGEXP end
  def valid_build_num_re() VALID_BUILD_NUM_REGEXP end
  def dut_version_re() DUT_VERSION_REGEXP end
  def input_version_re() INPUT_VERSION_REGEXP end
  def help(*args)
    command = args.shift
    if command.nil?
      msg = "Dut searcher:\n"
      msg += "Usage: <command> [args...]\n"
      msg += "    1. duts <accessible_only> <count> <scope>                                    list all DUTs\n"
      msg += "    2. vcd <name> <count> <scope>                                                search for a DUT contains specified VCD.\n"
      msg += "    3. version <compare> <version> <build_num> <count> <scope>                   search for a DUT with the specified version.\n"
      msg += "    4. host <release_num> <count> <scope>                                        search for a DUT hosting on specified OS.\n"
      msg += "Use \" help <command>\" to show  the detail information. (e.g. help duts).\n"
      msg += "quit   --->   exit\n\n"
      puts msg
    else
      case command
      when "duts"
        msg = "Usage\n"
        msg += "    duts <accessible_only> <count> <scope>\n\n"
        msg += "Description\n"
        msg += "    Use this command to search for the duts which can be accessed or not.\n\n"
        msg += "Arguments\n"
        msg += "    accessible_only            Use the flag to specify the dut you want must be accessed, it can accept the value \"yes\" or \"no\".\n"
        msg += "    count                      The count of the dut you want.\n"
        msg += "    scope                      Use the argument to specify the status of the dut you want, it can accept the value \"all\", \"idle\" or \"reserved\".\n\n"
        msg += "Example\n"
        msg += "    Find two idle duts which can be accessed.\n"
        msg += "    > duts yes 2 idle\n\n"
        puts msg
      when "vcd"
        msg = "Usage\n"
        msg += "    vcd <name> <count> <scope>\n\n"
        msg += "Description\n"
        msg += "    Use this command to search for the duts contain the specified vcd-name.\n\n"
        msg += "Arguments\n"
        msg += "    name                       The vcd name, it can only accept the value \"win2k12\" now, you can contact Franklin to add other VCD support.\n"
        msg += "    count                      The count of the dut you want.\n"
        msg += "    scope                      Use the argument to specify the status of the dut you want, it can accept the value \"all\", \"idle\" or \"reserved\".\n\n"
        msg += "Examples\n"
        msg += "    Find ten reserved duts which contain the vcd with the name win2k12.\n"
        msg += "    > vcd win2k12 2 reserved\n\n"
        puts msg
      when "version"
        msg = "Usage\n"
        msg += "    version <compare> <version> <build_num> <count> <scope>\n\n"
        msg += "Description\n"
        msg += "    Use this command to search for the duts with a rang version.\n\n"
        msg += "Arguments\n"
        msg += "    compare                    The compare symbol of version, it can accept the values \">\", \">=\", \"=\", \"<\", \"<=\".\n"
        msg += "    version                    The version point of the dut.\n"
        msg += "    build_num                  The build number of the dut.\n"
        msg += "    count                      The count of the dut you want.\n"
        msg += "    scope                      Use the argument to specify the status of the dut you want, it can accept the value \"all\", \"idle\" or \"reserved\".\n\n"
        msg += "Examples\n"
        msg += "    Find a idle dut which the version is before 7.4-127\n"
        msg += "    > version <= 7.4 127 1 idle\n\n"
        puts msg
      when "host"
        msg = "Usage\n"
        msg += "    host <release_num> <count> <scope>\n\n"
        msg += "Description\n"
        msg += "    Use this command to search for the duts which the specified host OS.\n\n"
        msg += "Arguments\n"
        msg += "    release_num                The release version of the host OS you want to find, it can accept the values \"centos-6.6\", \"centos-6.7\", \"centos-7.1\", \"centos-7.2\".\n"
        msg += "    count                      The count of the dut you want.\n"
        msg += "    scope                      Use the argument to specify the status of the dut you want, it can accept the value \"all\", \"idle\" or \"reserved\".\n\n"
        msg += "Examples\n"
        msg += "    Find a idle dut which the host OS is centos-6.6\n"
        msg += "    > host centos-7.1 1 idle\n\n"
        puts msg
      else
        puts "unsupported command #{command}"
      end
    end
  end
  def fetch_duts(mode="all")
    raise "unknown mode #{mode}" unless mode == "all" || mode == "idle" || mode == "reserved"
    data = nil
    duts = []
    Net::HTTP.start('134.111.24.33', 80) do |http|
      response = http.get('/')
      raise "Cannot talk to rinfo" unless response.code.to_i == 200
      data = response.body
    end
    data = data.gsub('target=_blank', 'target="_blank"')
    data = data.gsub('class=reserved', 'class="reserved"')
    data = data.gsub('class=idle', 'class="idle"')
    data = data.gsub('class=busy', 'class="busy"')
    data = data.gsub('>=', '=')
    data = data.gsub('<=', '=')
    data = data.gsub(/<a href=\S* onclick="return confirm\('Are you sure you want to release DUT [0-9a-zA-Z]{1,} \?'\);"\/>[0-9\?]*<\/a>/, '')
    begin_index = data.index('<tbody>')
    end_index = data.index('</tbody>')
    data = data[begin_index, end_index - begin_index + 8]
    doc = Document.new(data)
    empty = Element.new
    tr_xmls = doc.root
    (tr_xmls||empty).elements.each do |tr|
      td_xml = (tr||empty).elements['td']
      type = (td_xml||empty).attributes['class']
      dut_name = ((td_xml||empty).elements['a']||empty).text
      case mode
      when "all"
        duts << dut_name
      when "idle"
        duts << dut_name if type == "idle"
      when "reserved"
        duts << dut_name if type == "reserved"
      end
    end # end of block
    duts
  end
  private :fetch_duts
  def fetch_doh(dut)
    # puts "Get doh topo from DUT #{dut}"
    data = nil
    server = "#{dut}.sn.stratus.com"
    begin
      req = Net::HTTP::Post.new("http://#{server}/doh/")
      req.body = "<requests output='XML'><request id='1' target='supernova'><watch/></request></requests>"
      req.content_type = 'text/xml'
      Net::HTTP.start(server, 80) do |http|
        response = http.request(req)
        raise "Cannot talk to DUT #{dut}" unless response.code.to_i == 200
        data = response.body
      end
    rescue Exception => e
      # puts "error occured during fetch doh topo from DUT #{dut} => #{e}"
    end
    data
  end
  private :fetch_doh
  def duts(*args)
    accessible_only = args.shift
    puts "accessible_only is required (\"yes\" or \"no\")" if accessible_only.nil?
    raise "valid accessible_only values are \"yes\" and \"no\"" unless accessible_only == "yes" || accessible_only == "no"
    count = args.shift
    raise "count is required" if count.nil?
    count = 9999 if count.to_i == 0
    count = count.to_i
    mode = args.shift
    puts "Find DUT begin, this may take a few minutes."
    duts = mode.nil? ? fetch_duts : fetch_duts(mode)
    find_count = 0
    if accessible_only == "yes"
      duts.each do |dut|
        break if find_count >= count
        data = fetch_doh(dut)
        if !data.nil?
          puts dut
          find_count += 1
        end
      end
      puts "Total find #{find_count} DUTs"
    elsif accessible_only == "no"
      duts.each do |dut|
        break if find_count >= count
        puts dut
        find_count += 1
      end
      puts "Total find #{find_count} DUTs"
    end
  end
  def find_vcd(dest, pattern, scope, count)
    puts "Find VCD #{dest} begin, this may take a few minutes."
    got_count = 0
    duts = fetch_duts(scope)
    duts.each do |dut|
      break if got_count >= count
      data = fetch_doh(dut)
      next if data.nil?
      root = Document.new(data).root
      empty = Element.new
      outputs_xml = (root.elements['response']||empty).elements['output']
      (outputs_xml||empty).elements.each do |output_xml|
        next unless output_xml.name == 'volume'
        is_iso = (((output_xml.elements['media-info']||empty).elements['isiso']||empty).text||"false").to_bool
        if is_iso
          name = (output_xml.elements['name']||empty).text
          if name.match(pattern)
            puts "[Result] DUT #{dut} contains a #{dest} VCD"
            got_count += 1
            break
          end
        end
      end # end of volumes_xml block
    end # end of duts block
    puts "Total find #{got_count} DUTs"
  end
  private :find_vcd
  def vcd(*args)
    name = args.shift
    count = args.shift
    scope = args.shift || "all"
    raise "vcd name is reuired" if name.nil?
    raise "count is required" if count.nil?
    count = 9999 if count.to_i == 0
    raise "unsupported scope #{scope}" unless scope == "all" || scope == "idle" || scope == "reserved"
    case name
    when "win2k12"
      find_vcd("win2k12", win2k12_re, scope, count.to_i)
    else
      puts "unsupported VCD name, valid VCD names are: \"win2k12\""
    end
  end
  def compare_dut_ver(dut_ver, version, build_num)
    dut_ver_match_result = dut_ver.match(dut_version_re)
    input_ver_match_result = version.match(input_version_re)
    raise "Not a valid dut version #{dut_ver}" if dut_ver_match_result.nil?
    raise "Not a valid version #{version}" if input_ver_match_result.nil?
    # Convert DUT version
    dut_main_ver = dut_ver_match_result[1] || "0"
    dut_sub_ver = dut_ver_match_result[2] || "0"
    dut_build_num = dut_ver_match_result[3] || "0"
    dut_main_ver = dut_main_ver.to_i
    dut_sub_ver = dut_sub_ver.to_i
    dut_build_num = dut_build_num.to_i
    # Convert input version
    main_ver = input_ver_match_result[1] || "0"
    sub_ver = input_ver_match_result[2] || "0"
    main_ver = main_ver.to_i
    sub_ver = sub_ver.to_i
    build_num = build_num.to_i

    cmp_arr1 = []
    cmp_arr2 = []
    cmp_arr1 << dut_main_ver
    cmp_arr1 << dut_sub_ver
    cmp_arr1 << dut_build_num

    cmp_arr2 << main_ver
    cmp_arr2 << sub_ver
    cmp_arr2 << build_num

    compare_result = 0
    for i in 0 .. 2
      next if cmp_arr1[i] == cmp_arr2[i]
      if cmp_arr1[i] > cmp_arr2[i]
        compare_result = 1
        break
      elsif cmp_arr1[i] < cmp_arr2[i]
        compare_result = -1
        break
      end
    end
    return compare_result
  end
  private :compare_dut_ver
  def find_dut_by_version(version, build_num, count, scope, compare)
    puts "Find DUT #{compare} #{version}-#{build_num} begin, this may take a few minutes."
    got_count = 0
    duts = fetch_duts(scope)
    duts.each do |dut|
      break if got_count >= count
      data = fetch_doh(dut)
      next if data.nil?
      root = Document.new(data).root
      empty = Element.new
      outputs_xml = (root.elements['response']||empty).elements['output']
      dut_ver = (((outputs_xml||empty).elements['supernova']||empty).elements['version']||empty).text
      next if dut_ver.nil?
      case compare
      when ">"
        if compare_dut_ver(dut_ver, version, build_num) > 0
          puts "[Result] DUT #{dut}'s version is #{dut_ver}"
          got_count += 1
        end
      when "<"
        if compare_dut_ver(dut_ver, version, build_num) < 0
          puts "[Result] DUT #{dut}'s version is #{dut_ver}"
          got_count += 1
        end
      when "="
        if compare_dut_ver(dut_ver, version, build_num) == 0
          puts "[Result] DUT #{dut}'s version is #{dut_ver}"
          got_count += 1
        end
      when ">="
        if compare_dut_ver(dut_ver, version, build_num) >= 0
          puts "[Result] DUT #{dut}'s version is #{dut_ver}"
          got_count += 1
        end
      when "<="
        if compare_dut_ver(dut_ver, version, build_num) <= 0
          puts "[Result] DUT #{dut}'s version is #{dut_ver}"
          got_count += 1
        end
      end
    end # end of duts block
    puts "Total find #{got_count} DUTs"
  end
  private :find_dut_by_version
  VALID_COMPARE_SYMBOL = %w{> < = >= <=}
  def valid_compare?(compare)
    return VALID_COMPARE_SYMBOL.to_set.include?(compare)
  end

  def valid_version?(version)
    return version.match(valid_version_re)
  end
  def valid_build_num?(build_num)
    return build_num.match(valid_build_num_re)
  end
  def version(*args)
    compare = args.shift
    raise "compare is reuired" if compare.nil?
    raise "Not a valid compare, allowed values are #{VALID_COMPARE_SYMBOL}" unless valid_compare?(compare)
    version = args.shift
    raise "DUT version is reuired" if version.nil?
    raise "Not a valid version" unless valid_version?(version)
    build_num = args.shift
    raise "build number is reuired" if build_num.nil?
    raise "Not a valid build number" unless valid_build_num?(build_num)
    count = args.shift
    raise "count is required" if count.nil?
    count = 9999 if count.to_i == 0
    scope = args.shift || "all"
    raise "unsupported scope #{scope}" unless scope == "all" || scope == "idle" || scope == "reserved"
    find_dut_by_version(version, build_num, count.to_i, scope, compare)
  end
  def find_dut_by_relase_num(release_num, pattern, count, scope)
    puts "Find DUT with release #{release_num} begin, this may take a few minutes."
    got_count = 0
    duts = fetch_duts(scope)
    duts.each do |dut|
      break if got_count >= count
      result = %x{ftssh #{dut} cat /etc/redhat-release}
      next unless $?.success?
      if result.match(pattern)
        puts "[Result] DUT #{dut} is hosted on #{result}"
        got_count += 1
      end
    end # end of duts block
    puts "Total find #{got_count} DUTs"
  end
  private :find_dut_by_relase_num
  def host(*args)
    release_num = args.shift
    raise "release number is required" if release_num.nil?
    count = args.shift
    raise "count is required" if count.nil?
    count = 9999 if count.to_i == 0
    scope = args.shift || "all"
    raise "unsupported scope #{scope}" unless scope == "all" || scope == "idle" || scope == "reserved"
    case release_num
    when "centos-7.1"
      pattern = Regexp.new('CentOS release 7.1')
      find_dut_by_relase_num(release_num, pattern, count.to_i, scope)
    when "centos-6.6"
      pattern = Regexp.new('CentOS release 6.6')
      find_dut_by_relase_num(release_num, pattern, count.to_i, scope)
    when "centos-6.7"
      pattern = Regexp.new('CentOS release 6.7')
      find_dut_by_relase_num(release_num, pattern, count.to_i, scope)
    when "centos-7.2"
      pattern = Regexp.new('CentOS release 7.2')
      find_dut_by_relase_num(release_num, pattern, count.to_i, scope)
    else
      puts "unsupported release number, valid release numbers are: \"centos-7.1\", \"centos-7.2\", \"centos-6.6\", \"centos-6.7\""
    end
  end
  def quit
    Kernel.exit
  end
end

com = Commands.new

commands = com.methods - Object.methods

Readline.completion_proc = lambda { |s|
  commands.find_all { |e| e.match(s) }
}

loop do
  line = Readline.readline("> ", true)
  next if line == ""
  if line.nil?
    puts "\n"
    Kernel.exit
  end
  begin
    args = line.split
    command = args.shift
    if com.respond_to? command
      com.send(command.intern, *args)
    else
      puts "unsupported command #{command}"
    end
  rescue SystemExit => exception
    puts "Quitting: #{exception}\n"
    Kernel.exit
  rescue Exception => exception
    puts "Error executing #{line}\n"
    puts " == #{exception} == \n"
  end
end
