#!/usr/bin/ruby

require 'set'
require 'rexml/document'

$stdout.sync = true

CMD_KEYS_WITH_VALUE = %w{-input -output -auto-detect}
CMD_KEYS_WITHOUT_VALUE = %w{-v}

def key_with_value?(param)
  return CMD_KEYS_WITH_VALUE.to_set.include?(param)
end

def key_without_value?(param)
  return CMD_KEYS_WITHOUT_VALUE.to_set.include?(param)
end

def parse_cmd(params)
  cmd_hash = Hash.new
  key_detected = nil
  params.each do |param|
    current_param = param.chomp
    if key_with_value?(current_param)
      if key_detected
        raise "value if required for key #{key_detected}"
      else
        cmd_hash[current_param] = nil
        key_detected = current_param
      end
    elsif key_without_value?(current_param)
      cmd_hash[current_param] = true
      key_detected = nil
    else
      cmd_hash[key_detected] = current_param
      key_detected = nil
    end
  end
  raise "value if required for key #{key_detected}" if key_detected
  cmd_hash
end

def do_html_to_xml(input, output, verbose = true)
    html_to_xml = HtmlToXml.new(input, output, verbose)
    html_to_xml.load
    html_to_xml.analysis
    html_to_xml.write
end

class HtmlToXml
  include REXML
  attr_accessor :verbose
  attr_accessor :html_file
  attr_accessor :xml_file
  attr_accessor :html_content
  attr_accessor :xml_content
  attr_accessor :html_hash
  HTML_REGEXP = Regexp.new('\S*[.]html', true)
  XML_REGEXP = Regexp.new('\S*[.]xml', true)
  def initialize(input, output, v)
    html?(input)
    xml?(output)
    self.html_file = input
    self.xml_file = output
    self.verbose = v
    self.html_hash = Hash.new
  end
  def log
    puts yield if self.verbose
  end
  def log_warn
    msg = "WARN #{yield}"
    log {msg}
  end
  def log_debug
    msg = "DEBUG #{yield}"
    log {msg}
  end
  def html?(file)
    raise "HTML file #{file} is required" if file.nil? || !File.exists?(file)
    raise "#{file} is not a HTML file" unless HTML_REGEXP.match(file)
  end
  def xml?(file)
    raise "XML file #{file} is required" if file.nil?
    raise "#{file} is not a XML file" unless XML_REGEXP.match(file)
  end
  def parse_html_str(orig_html_str)
    begin_index = orig_html_str.index('<dl>')
    end_index = orig_html_str.index('</dl>')
    return orig_html_str[begin_index, end_index - begin_index + 5]
  end
  def load_html
    html_str = ""
    File.open(self.html_file) { |f|
      while line = f.gets
        html_str += "#{line}"
      end
    }
    html_str = parse_html_str(html_str)
    self.html_content = begin Document.new(html_str) rescue nil end
    raise "Failed to load HTML from #{self.html_file}" if self.html_content.nil?
  end
  def load_xml
    xml_str = ""
    if File.exist?(self.xml_file)
      File.open(self.xml_file) { |f|
        while line = f.gets
          xml_str += "#{line}"
        end
      }
    else
      xml_str = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
      xml_str += "<!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\">\n"
      xml_str += "<!--Copyright (C) 2007 Stratus Technologies Bermuda Ltd. All rights reserved-->\n"
      xml_str += "<!--Confidential and proprietary.-->\n"
      xml_str += "<properties>\n"
      xml_str += "\t<!-- Note, AUTHORIZATION_FAILED is not an AuditType -->\n"
      xml_str += "</properties>"
    end

    self.xml_content = begin Document.new(xml_str) rescue nil end
    self.xml_content.context[:attribute_quote] = :quote # Make sure all attributes are with double quotation marks
    raise "Failed to load XML from #{self.xml_file}" if self.xml_content.nil?
  end
  def load
    load_html
    load_xml
  end
  def analyse_html
    key_detected = nil
    nodes = self.html_content.root
    nodes.elements.each do |node|
      case node.name
      when "dt"
        key = begin node.text rescue nil end
        log_warn {"value expected for key #{key_detected}"} if key_detected
        log_warn {"duplicate key #{key} found"} unless self.html_hash[key].nil?
        self.html_hash[key] = nil
        key_detected = key
      when "dd"
        value = begin node.elements['code'].text rescue nil end
        value = value.gsub(/[\n\t]{1,}/, " ") # In case there is '\n' or '\t' in string
        log_warn {"key expected for value #{value}"} unless key_detected
        self.html_hash[key_detected] = value
        key_detected = nil
      end
    end
  end
  def analyse_xml
    nodes = self.xml_content.root
    # Change the original XML if the value is not the same as what it is in HTML
    nodes.elements.each do |node|
      key = begin node.attributes['key'] rescue nil end
      value = begin node.text rescue nil end
      if self.html_hash[key] && self.html_hash[key] != value
        node.text = self.html_hash[key]
        self.html_hash.delete(key)
      end
    end
    self.html_hash.each_key do |key|
      entry = Element.new("entry")
      entry.add_attribute("key", key)
      entry.add_text("#{self.html_hash[key]}")
      nodes.add_element(entry)
    end
  end
  def analysis
    analyse_html
    analyse_xml
  end
  def format(xml)
    output_str = "#{xml}"
    properties_end_index = output_str.index("</properties>")
    if (output_str[properties_end_index - 1] == ">")
      output_str.insert(properties_end_index, "\n")
    end
    output_str = output_str.gsub(/\n<entry/, "\n\t<entry")
    output_str = output_str.gsub(/><entry/, ">\n\t<entry")
    output_str = output_str.gsub("><", ">\n<")
    output_str = output_str.gsub("&quot;", "\"")
    output_str = output_str.gsub("&apos;", "'")
    output_str = output_str.gsub("<?xml version='1.0' encoding='UTF-8'?>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
    output_str
  end
  def write
    final_xml = format(self.xml_content)
    file = File.new(self.xml_file, "w+")
    file.puts final_xml
    file.close
  end
end

class SourceHtmlLoader
  attr_accessor :root_path
  BUNDLE_PREFIX_REGEXP = Regexp.new('StringBundles_([a-z\-_]{1,})')

  def initialize(root_path)
    self.root_path = "#{root_path}/unity-help/help/FlareSources"
  end

  def get_bundle(bundle_folder)
    matched_str = BUNDLE_PREFIX_REGEXP.match(bundle_folder)
    return matched_str.nil? ? "UNKNOWN" : matched_str[1]
  end

  def load_htmls
    audit_htmls = Hash.new
    bundle_folders = Dir.glob("#{self.root_path}/*")
    bundle_folders.each do |bundle_folder|
      if File.directory?(bundle_folder) 
        audit_html_file = "#{bundle_folder}/audit.html"
        if File.exists?(audit_html_file)
          bundle = get_bundle(bundle_folder)
          bundle = "en" if bundle == "en-us"
          puts "find source HTML file #{audit_html_file} for language bundle #{bundle}"
          audit_htmls[bundle] = audit_html_file
        end
      end
    end # end of bundle_folders block
    audit_htmls
  end
end

begin
  params = ARGV
  cmd_hash = parse_cmd(params)
  if (cmd_hash["-auto-detect"])
    root_path = cmd_hash["-auto-detect"]
    source_html_loader = SourceHtmlLoader.new(root_path)
    audit_htmls = source_html_loader.load_htmls
    audit_htmls.each_key do |bundle|
      input_file = audit_htmls[bundle]
      output_file = "#{root_path}/unity-mgmt/sm/java/smd-main/i18n/audit_#{bundle}.xml"
      do_html_to_xml(input_file, output_file)
    end # end of audit_htmls block
  else
    do_html_to_xml(cmd_hash["-input"], cmd_hash["-output"], cmd_hash["-v"])
  end
rescue Exception => e
  raise
end
