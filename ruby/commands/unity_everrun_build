#!/usr/bin/ruby

#=============================================================================

# Use example:
# ./unity_everrun_build {workspace_path} {dut_name}
#                             $1             $2
#                       shanghai_build     greece

#=============================================================================

# This script is used to do the complete build for everrun.

#=============================================================================

require 'timeout'

$stdout.sync = true

$WORKSPACE_PATH = ARGV[0].to_s
$DUT_NAME = ARGV[1].to_s
$USER_NAME = %x{whoami}

class Main
  attr_accessor :workspace_path
  attr_accessor :dut_name
  attr_accessor :user_name
  def initialize
    self.workspace_path = "#{$WORKSPACE_PATH}"
    self.dut_name = "#{$DUT_NAME}"
    self.user_name = "#{$USER_NAME}"
    prepare_params
    check_params
    show_params
  end
  DUT_RESERVER_REGEXP = "Reserved: ([a-zA-Z]{1,})[ ]"
  def buid_finished_regexp
    if @build_finished.nil?
      @build_finished = Regexp.new("make\\[1\\]: Leaving directory \\`/developer/fzhang/#{self.workspace_path}/unity-stratus/upgrade")
    end
    Regexp.new("make\\[1\\]: Leaving directory \\`/developer/fzhang/#{self.workspace_path}/unity-stratus/upgrade")
  end
  def build_info_file() "/developer/#{self.user_name}/#{self.workspace_path}/unity-build/build_info.out" end
  def kit_folder() "/developer/#{self.user_name}/#{self.workspace_path}/unity-build/kit" end
  def deploy_folder() "/test_logs1/#{self.user_name}/#{self.workspace_path}" end
  def backup_folder() "/test_logs1/#{self.user_name}/#{self.workspace_path}.backup" end
  def show_params
    puts "Received params: workspace path = #{self.workspace_path}, dut name = #{self.dut_name}, user name = #{self.user_name}"
  end
  def check_params
    if self.workspace_path.nil? || self.dut_name.nil?
      raise "Please input the parameters!"
    end
  end
  def prepare_params
    self.user_name.chomp!
    self.workspace_path.chomp!
    self.dut_name.chomp!
  end
  def check_dut_available
    puts "===================begin to check dut available========================"
    rinfo_message = %x{rinfo | grep "^#{self.dut_name} *[0-9]*%"}
    dut_reserver_regexp = "Reserved: (#{self.user_name})[ ]"
    if rinfo_message.nil?
      raise "The dut #{self.dut_name} does not exist!"
    elsif rinfo_message.match(dut_reserver_regexp)
      puts "The dut is reserved by #{self.user_name}"
    else
      raise "Only the dut is reserved by yourself, then you can build everrun to it, but the dut #{self.dut_name} is: \n#{rinfo_message}"
    end
  end
  def verify_access
    puts "===================begin to verify the access========================"
    begin
      timeout(10) {%x{ftssh #{self.dut_name}}}
    rescue => e
      raise "Cannot access build server, #{e}"
    end
    puts "===================verified successfully========================"
  end
  def source_code_exist?
    workspace = "/developer/#{self.user_name}/#{self.workspace_path}"
    source_code_folder = "#{workspace}/unity-build"
    if File.exist?(workspace) &&  File.exist?(source_code_folder)
      return true
    else
      return false
    end
  end
  def modify_config_mk(config_file)
    begin
      content = []
      io = File.open(config_file)
      io.each_line do |line|
        line.chomp!
        if line == "RELEASE:=R$(MAJOR_REV).$(MINOR_REV).$(MAINT_REV)"
          content << "UNITY_PACKAGER := #{self.user_name}\n"
        end
        content << "#{line}\n"
      end
      io.close
      io = File.open(config_file, 'w')
      io.puts content
      io.close
    rescue Exception => e
      puts "Failed to modify Config.mk => #{e}"
    end
  end
  def fetch_source_code
    puts "===================begin to get the source code of everrun from GitHub========================"
    dest_folder = "/developer/#{self.user_name}/#{self.workspace_path}"
    %x{mkdir -p #{dest_folder}}
    %x{git clone git@github.com:stratustech/unity-stratus #{dest_folder}/unity-stratus}
    %x{git clone git@github.com:stratustech/unity-drivers #{dest_folder}/unity-stratus/unity-drivers}
    %x{git clone git@github.com:stratustech/unity-third-party #{dest_folder}/unity-stratus/unity-third-party}
    %x{git clone git@github.com:stratustech/unity-libvirt #{dest_folder}/unity-stratus/unity-libvirt}
    modify_config_mk("#{dest_folder}/unity-stratus/Config.mk")
    # %x{sed -i \"76c UNITY_PACKAGER := #{self.user_name}\" #{dest_folder}/unity-stratus/Config.mk}
    %x{ln -s #{dest_folder}/unity-stratus #{dest_folder}/unity-build}
    puts "===================cloned successfully========================"
  end
  def compile_source_code
    puts "===================begin to exec make (do not delete the file build_info.out generated in the source code folder)========================"
    File.delete(build_info_file) if File.exist?(build_info_file)
    IO.popen("ssh #{self.user_name}@shanghai6.sn.stratus.com /developer/#{self.user_name}/script/common/compile_everrun #{self.workspace_path}") { |io|
      while line = io.gets
        line.chomp!
        puts line
        File.open(build_info_file, "a") { |f|
          f.write "#{line}\n"
        }
      end
    }
    puts "===================exec make finished, wait until the compile is done========================"
  end
  def build_finished?
    is_finished = false
    if File.exist?(kit_folder)
      kit_file = Dir.glob("#{kit_folder}/*.kit")
      iso_file = Dir.glob("#{kit_folder}/*.iso")
      if kit_file.length > 0 && iso_file.length > 0
        is_finished = true
      end
    end
    is_finished
  end
  def ready_to_run_fttest?
    local_file = "#{deploy_folder}/local"
    project_file = "#{deploy_folder}/project"
    if File.exist?(deploy_folder) && File.exist?(local_file) && File.exist?(project_file)
      return true
    else
      return false
    end
  end
  def prepare_fttest_folder
    puts "===================prepare to run fttest========================"
    start_time = Time.now
    time_limit = 30 * 60 # 30min
    while true
      current_time = Time.now
      interval = current_time - start_time
      if interval > time_limit
        raise "Timeout waiting for build finished"
      end
      break if build_finished?
      sleep 30
    end
    puts "find the compile is finished, will begin to run fttest"
    %x{mkdir -p #{deploy_folder}}
    %x{ln -s /test_logs/fttest2/unity/current #{deploy_folder}/project}
    %x{ln -s /developer/#{self.user_name}/#{self.workspace_path}/unity-build #{deploy_folder}/local}
    puts "===================prepare finished======================="
  end
  def fttest_success?(dut_name)
    %x{curl http://#{dut_name}.sn.stratus.com}
    return $?.success?
  end
  def backup_origin_log
    puts "copy original log files to #{backup_folder}"
    %x{cp -rv #{deploy_folder}/sn/* #{backup_folder}}
  end
  def run_fttest
    puts "===================begin to run fttest========================"
    run_fttest_cmd = "/developer/#{self.user_name}/script/common/run_fttest #{deploy_folder} #{self.dut_name}"
    IO.popen(run_fttest_cmd) { |io|
      while line = io.gets
        line.chomp!
        puts line
      end
    }
    puts "===================deploy finished======================="
  end
  def run
    # verify_access
    if source_code_exist?
      puts "source code already exists"
    else
      fetch_source_code
    end
    if build_finished?
      puts "source code has already been compiled"
    else
      compile_source_code
    end
    if ready_to_run_fttest?
      puts "already ready to run fttest"
    else
      prepare_fttest_folder
    end
    run_fttest
    if !fttest_success?(self.dut_name)
      puts "fttest failed, try for a second time"
      backup_origin_log
      run_fttest
    end
  end
end

begin
  main = Main.new
  main.run
rescue Exception => e
  puts "Error occured during executing build => #{e}"
  raise
end
