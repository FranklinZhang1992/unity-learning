/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.9 2005/01/07 09:37:18 dts12 Exp $
 */

#include <ctype.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <signal.h>
#include <getopt.h>
#include <fcntl.h>
#include <time.h>
#include <pthread.h>
#include <errno.h>
#include <regex.h>

#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <libxml/xmlreader.h>

#include <sys/time.h>
#include <sys/resource.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/utilities.h>
#include "stratus.h"
#include "stratus_checkfns.h"
#include "stratus_access.h"
#include "stratus_enums.h"

#define XML_CONFIG_FILE "/shared/smd/CallHomeInfo.xml"
#define XML_TEMP_FILE "/etc/snmp/tempxml"
#define INIT_HTTP_RESPONSE_SIZE 100000

/*
 * Global variables
 */

int process_doh_request( int , char ** );

static int keep_running;
int enable_requests = 0;

pthread_mutex_t doh_mutex = PTHREAD_MUTEX_INITIALIZER;

struct hostent *http_hostent;
struct sockaddr_in doh_address;
int doh_sock = -1;
int http_string_length, xml_string_length;
int sent_bytes, received_bytes;
char http_request[1024];
char *http_response = NULL;
int http_response_size = 0;
char login_request[1024];
char login_username[256];
char login_password[256];
char current_session_id[256];
time_t lastcredtime = 0;
time_t lastalerttime = 0;
time_t lastaudittime = 0;
time_t lastconfigtime = 0;
time_t lasthosttime = 0;
time_t lastsupernovatime = 0;
time_t lastusertime = 0;
time_t laststoragetime = 0;
char salt1[] = "avance";
int salt1len = 6;
char salt2[] = "EVERrun";
int salt2len = 7;
char secret[] = "NNY";
int secretlen = 3;

struct alertLogEntry {
   struct alertLogEntry *next_ptr;
   char alertID[40];
   char logID[40];
   char *source;
   char *timestamp;
   char *explain_text;
   char *type;
   char *SNMPtrap_OID;
   int severity;
   int callhome_sent;
   int eAlert_sent;
   int SNMPtrap_sent;
};

struct auditLogEntry {
   struct auditLogEntry *next_ptr;
   char *index;
   char *day;
   char *timestamp;
   char remotehost[4];
   char *remoteuser;
   char *description;
};

struct alertLogEntry *alertTableList = NULL;
struct auditLogEntry *auditTableList = NULL;
struct alertLogEntry *doh_alertTableList = NULL;
struct auditLogEntry *doh_auditTableList = NULL;
struct alertLogEntry *alertTableWalkList = NULL;
struct auditLogEntry *auditTableWalkList = NULL;

int doh_alertTableFlag = 0;
int doh_auditTableFlag = 0;

char *blank = " ";

struct in_addr ipAddress;
struct in_addr doh_ipAddress;
char *systemName = NULL;
char *doh_systemName = NULL;
int systemMemory = 0;
int doh_systemMemory = 0;
int systemCPUs = 0;
int doh_systemCPUs = 0;
int systemUsedCPUs = 0;
int doh_systemUsedCPUs = 0;
int systemMaxCPUsPerVM = 0;
int doh_systemMaxCPUsPerVM = 0;
int systemState = 0;
int doh_systemState = 0;
char *systemSerial = NULL;
char *doh_systemSerial = NULL;
char *systemSiteID = NULL;
char *doh_systemSiteID = NULL;
int systemStorageUsed = 0;
int doh_systemStorageUsed = 0;
int systemStorageFree = 0;
int doh_systemStorageFree = 0;
int systemStorageTotal = 0;
int doh_systemStorageTotal = 0;


int in_alert = 0;
int in_audit = 0;
int in_log = 0;
int in_callhome = 0;
int in_ealert = 0;
int in_snmp = 0;

long long host_storage_total[2];

char *alertTablePtr = "alert table";
long alertIndex = 1;
long *alertIndexPtr = &alertIndex;
long alertSeverity = 0;
long *alertSeverityPtr = &alertSeverity;
char *alertTypePtr = "alert type";
char *alertSNMPTrapOIDPtr = NULL;
char *alertSourcePtr = "alert source";
char *alertDateTimePtr = "today";
long alertCallHomeSent = 0;
long *alertCallHomeSentPtr = &alertCallHomeSent;
long alertEAlertSent = 0;
long *alertEAlertSentPtr = &alertEAlertSent;
long alertSNMPTrapSent = 0;
long *alertSNMPTrapSentPtr = &alertSNMPTrapSent;
char *alertInformationPtr = "alert info";

char *auditTablePtr = "audit table";
long auditIndex = 1;
long *auditIndexPtr = &auditIndex;
char auditDateTime[80];
char *auditDateTimePtr = "today";
char *auditUsernamePtr = "me";
char *auditOriginatingHostPtr = "my DUT";
char *auditActionPtr = "none";

int loopContext = 1;
int noLoopContext = 0;
int indexdata = 1;

/*
 *  List of DOH requests
 */

#define DOH_SUPERNOVA 0
#define DOH_LOGIN 1
#define DOH_SYSTEM_STATUS 2
#define DOH_SYSTEM_NAME 3
#define DOH_SERIAL_NUMBER 4
#define DOH_SITE_ID 5
#define DOH_AVAIL_VIRTUAL_MEMORY 6
#define DOH_VIRTUAL_CPU_TOTAL 7
#define DOH_VIRTUAL_CPU_IN_USE 8
#define DOH_VIRTUAL_CPUS_MAX_PER_VM 9
#define DOH_VIRTUAL_CPUS_PERCENTAGE_USED 10
#define DOH_STORAGE_TOTAL 11
#define DOH_STORAGE_USED 12
#define DOH_STORAGE_USED_BY_MANAGEMENT 13
#define DOH_STORAGE_FREE 14
#define DOH_DISK_READ_BYTES 15
#define DOH_DISK_WRITE_BYTES 16
#define DOH_NETWORK_READ_BYTES 17
#define DOH_NETWORK_WRITE_BYTES 18
#define DOH_ALERT_TABLE 19
#define DOH_AUDIT_TABLE 20
#define DOH_LOGOUT 21

/*
 *  Error constants
 */
#define DOH_SUCCESS 0
#define DOH_RESPONSE -1
#define DOH_NEED_LOGIN -2

char *xml_supernova_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"20\" target=\"supernova\"><select></select></request></requests>";

char *xml_login_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"10\" target=\"session\"><login><username><![CDATA[%s]]></username><password><![CDATA[%s]]></password></login></request></requests>";

char *xml_logout_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"10\" target=\"session\"><logout /></request></requests>";

char *xml_host_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"20\" target=\"host\"><select></select></request></requests>";

char *xml_user_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"1\" target=\"user\"><viewOwner/></request></requests>";

/*
char *xml_storage_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"1\" target=\"storage\"><select></select></request></requests>";
*/

char *xml_sharedstorage_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"1\" target=\"sharedstorage\"><select></select></request></requests>";

char *xml_volume_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"1\" target=\"volume\"><select>volume/size</select></request></requests>";

/*
char *xml_storage_total_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"1\" target=\"storage\"><select></select></request></requests>";
*/

char *xml_alert_table_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"1\" target=\"alert\"><select></select></request></requests>";

char *xml_audit_table_request = "<?xml version=\"1.0\" encoding=\"utf-8\"?><requests output=\"XML\"><request id=\"1\" target=\"audit\"><select></select></request></requests>";

/*
 * The following lines were automatically generated by mib2c.
static netsnmp_oid_stash_node *undoStorage = NULL;
static netsnmp_oid_stash_node *commitStorage = NULL;
*/

/* static oid      snmptrap_oid[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 }; */

static oid      sraProductIdEverRun_oid[] =
                                 { 1, 3, 6, 1, 4, 1, 458, 104, 15, 1 };
/*
static oid      everRunAlertTableIndex_oid[] =
                                 {1, 3, 6, 1, 4, 1, 458, 115, 1, 10, 1, 1, 1};
static oid      everRunAuditTableIndex_oid[] =
                                 {1, 3, 6, 1, 4, 1, 458, 115, 1, 12, 1, 1, 1};
*/


struct undoInfo {
    void           *ptr;
    size_t          len;
};

struct commitInfo {
    void           *data_context;
    int             have_committed;
    int             new_row;
};

/*
 * Routine stop_server is called to break us out of the loop waiting
 * for incoming SNMP requests.
 */

RETSIGTYPE
stop_server(int a) {
    keep_running = 0;
}

/*
 * A couple of utility routines to copy XML data.
 */

static char * copy_string (char * src)
{
  int copy_len;
  char * copy;

  if (src) {  // only if not null
    copy_len = strlen (src);
    copy = malloc (copy_len + 1);
    strncpy (copy, src, copy_len);
    copy[copy_len] = 0;
    return copy;
  }
  else {
    return NULL;
  }
}

static int copy_integer (char * src)
{
  if (src) {
    return atoi (src);
  }
  else {
    return 0;
  }
}

// Get the value associated with a tag; for example, if the
// following line is in the xml file:
//
//  <iceCreamFlavor>vanilla</iceCreamFlavor>
//
// and tagName points to "iceCreamFlavor", then return a
// value of "vanilla"
int get_tag_value( xmlTextReaderPtr reader, const xmlChar **name,
                   char *tagName, char **value ) {

  int ret;
  const xmlChar *read_value;

  // we've just read the tag name; read the next element
  // (which should be the value)
  ret = xmlTextReaderRead(reader);
  if ( ret != 1 ) return (ret);
  *name = xmlTextReaderConstName(reader);
  read_value = xmlTextReaderConstValue(reader);


  // if there was no value, for example:
  //
  //   <iceCreamFlavor></iceCreamFlavor>
  //
  // then, we will have gotten the tag name back
  // as the "name"; if this is the case, we skip
  // getting the value
  if ( strcmp( (char *) *name, tagName ) != 0 ) {
     /*if (*value != NULL) free (*value);a*/
     *value = copy_string( (char *) read_value );

     // read the ending tag (for example,
     // </iceCreamFlavor> returns "iceCreamFlavor")

     ret = xmlTextReaderRead(reader);
     *name = xmlTextReaderConstName(reader);
  }
  return(ret);
}


//
// Get configuration information from the xml file
void get_config_from_xml(){

  xmlTextReaderPtr reader;
  const xmlChar *name, *value;
  int ret;
  char * temp_value = 0;
  int in_snmp = 0;

  // Only read the config file every 30 seconds

  if ( ( time(0) - lastconfigtime ) < 30 )
     return;

  // access the xml file
  reader = xmlReaderForFile(XML_CONFIG_FILE, NULL, 0);
  if (reader != NULL) {

    // loop through all the info in the xml file, a
    // line at a time
    while ((ret = xmlTextReaderRead(reader)) == 1) {

      // get the name just read
      name = xmlTextReaderConstName(reader);

      // if we got a name, read its associated value
      if ( name != NULL) {
        value = xmlTextReaderConstValue(reader);
      }

      // if we see the tag "snmp" and this isn't an
      // empty element (i.e., it doesn't equal an empty
      // tag such as "<iceCreamFlavor/>", then toggle the
      // value of in_snmp -- which indicates whether or
      // not we're in the "snmp" portion of the xml
      // file.  Note that the first time we see it, we're
      // entering the snmp section (so we set in_snmpp
      // to 1) and the next time we see it, we're exiting
      // the section (so in_snmp is 0)
      if ( ( strcmp( (char *) name, "snmp" ) == 0 ) &&
           ( xmlTextReaderIsEmptyElement(reader) == 0 ) ) {
        if ( in_snmp ) in_snmp = 0;
        else in_snmp = 1;
      }

      else if ( in_snmp == 1 ) {

        // the "enableRequests" tag
        if ( strcmp( (char *) name, "enableRequests") == 0 ) {
          //  if this is an empty tag (<enableRequests/>), skip it
          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;

          // get the value associated with this tag
          ret = get_tag_value( reader, &name, "enableRequests", &temp_value );
          if ((ret == 1) && (temp_value != NULL)) {

            // if we got a value and it's "true", set enable_requests to 1;
            // if it's false, set enable_requests to 0; if it's any other
            // value, leave enable_requests alone
            if ( strcmp( temp_value, "true" ) == 0 ) enable_requests = 1;
            else if ( strcmp ( temp_value, "false" ) == 0 ) enable_requests = 0;

            // free the memory we used
            free(temp_value);
            temp_value = NULL;
          }
        }

      } /* end in snmp */

    } /* end while */

    // free the XML reader
    xmlFreeTextReader(reader);

    lastconfigtime = time( 0 );

  } /* end reader != NULL */
}


//
// Get configuration information from the xml file
char * get_value_from_xml(char *buffer, int buflen,
                          char* tagname, int occurrence){

  xmlTextReaderPtr reader;
  const xmlChar *name, *found_name;
  char *value = NULL;
  int ret;
  int occurrences = 0;

  // access the xml file
  reader = xmlReaderForFile(XML_TEMP_FILE, 0, 0);
  if (reader != NULL) {

    // loop through all the info in the xml file, a
    // line at a time
    while ((ret = xmlTextReaderRead(reader)) == 1) {

      // get the name just read
      found_name = xmlTextReaderConstName(reader);

      if ( found_name <= 0 ) {
         printf("error in xmlTextReaderConstName\n");
      }

      // if we see the passed-in tag and this isn't an
      // empty element (i.e., it doesn't equal an empty
      // tag such as "<iceCreamFlavor/>", then check to
      // see if we've reached the nth occurrence (as
      // requested by the input argument.
      if ( strcmp( (char *) found_name, tagname ) == 0 ) {

         occurrences++;

         // if there is a value for this tag, get it
         if ( xmlTextReaderIsEmptyElement(reader) == 1 ) {
           xmlFreeTextReader(reader);
           return( NULL );
         }

         ret = get_tag_value( reader, &name, tagname, &value );
         if ( occurrences == occurrence ) {
           xmlFreeTextReader(reader);
           return( value );
         }
      }
    } /* end while */

    // free the XML reader
    xmlFreeTextReader(reader);
    return( NULL );
  }
  return( NULL ); /* end reader != NULL */
}


/*
 *  populate_login_scalars takes a previously fetched XML
 *  message that contains login session info and sets scalar
 *  values based on that info.
 */
int populate_login_scalars( char *xml_ptr ) {

    xmlTextReaderPtr reader;

    int ret;
    const xmlChar *name;
    char *temp_value;

    /*
     *  Access the XML message (already read into memory).
     */
    reader = xmlReaderForFile(XML_TEMP_FILE, 0, 0);
    if (reader == NULL)
        return(0);

    /*
     *  Loop through all the info in the XML message, a
     *  line at a time.
     */
    while ((ret = xmlTextReaderRead(reader)) == 1) {

        /* Get the name just read. */
        name = xmlTextReaderConstName(reader);

        if ( strcmp( (char *) name, "login" ) == 0 ) {

            /*
             *  We have a "login" tag.
             *  If it is empty, there was an error logging in.
             */
            if ( xmlTextReaderIsEmptyElement(reader) == 1 ) return(0);
        }
        else if ( strcmp( (char *) name, "session-id" ) == 0 ) {

            /* We have a "session-id" tag. */
            if ( xmlTextReaderIsEmptyElement(reader) == 1 ) return(0);

            ret = get_tag_value( reader, &name, "session-id", &temp_value );

            /* If we got a value, save the session ID globally. */
            if ((ret == 1) && (temp_value != NULL)) {

                strncpy(current_session_id, temp_value,
                        sizeof(current_session_id));
                current_session_id[sizeof(current_session_id)-1] = '\0';
                free(temp_value);
                temp_value = NULL;
                printf("Using authenticated session ID: %s\n", current_session_id);
            }

        } /* end while */
    }

    /*
     *  Free the XML reader.
     */
    xmlFreeTextReader(reader);
    return(1);
}

/*
 * Check for login errors.
 */
int check_need_login(const xmlChar *name, xmlTextReaderPtr reader)
{
    int ret = 0;
    char *temp_value = NULL;

    if (strcmp((char *)name, "error") == 0) {
        if (xmlTextReaderIsEmptyElement(reader) == 1) return 0;
        ret = get_tag_value(reader, &name, "error", &temp_value);

        if ((ret == 1) && (temp_value != NULL))
            if (strstr(temp_value, "login required") != NULL)
                ret = DOH_NEED_LOGIN;

        if (temp_value != NULL)
            free(temp_value);
    }

    return ret;
}

/*
 *  populate_supernova_scalars takes a previously fetched XML
 *  message that contains Supernova info and sets scalar
 *  values based on that info.
 */

int populate_supernova_scalars( char *xml_ptr ) {

   xmlTextReaderPtr reader;

   int ret, status;
   const xmlChar *name;
   char *temp_value;
   long long  memory_int64;

   /*
    *  Free any elements already on the alert list.
    */
#if 0
   while ( alertTableList != NULL ) {

      alert_entry = alertTableList;
      if ( alert_entry->source != NULL )
         free ( alert_entry->source );
      if ( alert_entry->timestamp != NULL )
         free ( alert_entry->timestamp );
      if ( ( alert_entry->explain_text != NULL ) &&
           ( alert_entry->explain_text != blank ) )
         free ( alert_entry->explain_text);
      if ( alert_entry->type != NULL )
         free ( alert_entry->type );
      if ( ( alert_entry->SNMPtrap_OID != NULL ) &&
           ( alert_entry->SNMPtrap_OID != blank ) )
         free ( alert_entry->SNMPtrap_OID);

      alertTableList = alert_entry->next_ptr;
   }

   alert_entry = NULL;
#endif

   /*
    *  Access the XML message (already read into memory).
    */

   reader = xmlReaderForFile(XML_TEMP_FILE, 0, 0);
   if (reader == NULL)
      return(0);

   /*
    *  Free previous value.
    */

   if ( ( systemName != NULL ) && ( systemName != blank ) ) {
      free( systemName );
      systemName = blank;
   }


   /*
    *  Loop through all the info in the XML message, a
    *  line at a time.
    */

   while ((ret = xmlTextReaderRead(reader)) == 1) {

      /*
       *  Get the name just read.
       */

      name = xmlTextReaderConstName(reader);

      /*
       * Check if DOH requires a login.
       * If it does, return DOH_NEED_LOGIN to login and retry.
       */
      ret = check_need_login(name, reader);
      if ( ret < 0 ) {
          xmlFreeTextReader(reader);
          return ret;
      }

      if ( strcmp( (char *) name, "management-ip" ) == 0 ) {

        /*
         *  We have a "management-ip" tag.
         *  Get its value if the tag is not empty.
         */

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;

        ret = get_tag_value( reader, &name, "management-ip", &temp_value );

        /*
         *  If we got a value, set the appropriate info in our new
         *  alert entry.
         */

        if ((ret == 1) && (temp_value != NULL)) {

            status = inet_aton( temp_value, &ipAddress );

            free(temp_value);
            temp_value = NULL;
        }
      }

      /*
       *  The "name" tag...
       */

      else if ( strcmp( (char *) name, "name" ) == 0 ) {

        /*
         *  If there is a value for this tag, get it.
         */

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
        ret = get_tag_value( reader, &name, "name", &systemName );

        if ( systemName == 0 ) systemName = blank;

      }

      /*
       *  The "memory-total" tag...
       */

      else if ( strcmp( (char *) name, "memory-total" ) == 0 ) {

        /*
         *  If there is a value for this tag, get it.
         */

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
        ret = get_tag_value( reader, &name, "memory-total", &temp_value );

        /*
         *  Convert to megabytes.
         */

        if ( temp_value > 0 ) {

          memory_int64 = atoll( temp_value );
          systemMemory = memory_int64 / 1048576;

          free( temp_value );
        }

        temp_value = NULL;
      }

      /*
       *  The "vcpus-total" tag...
       */

      else if ( strcmp( (char *) name, "vcpus-total" ) == 0 ) {

        /*
         *  If there is a value for this tag, get it.
         */

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
        ret = get_tag_value( reader, &name, "vcpus-total", &temp_value );

        /*
         *  Convert to megabytes.
         */

        if ( temp_value > 0 ) {

          systemCPUs = atoi( temp_value );

          free( temp_value );
        }

        temp_value = NULL;
      }

      /*
       *  The "vcpus-used" tag...
       */

      else if ( strcmp( (char *) name, "vcpus-used" ) == 0 ) {

        /*
         *  If there is a value for this tag, get it.
         */

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
        ret = get_tag_value( reader, &name, "vcpus-used", &temp_value );

        /*
         *  Convert to megabytes.
         */

        if ( temp_value > 0 ) {

          systemUsedCPUs = atoi( temp_value );

          free( temp_value );
        }

        temp_value = NULL;
      }

      /*
       *  The "vcpus-max-per-vm" tag...
       */

      else if ( strcmp( (char *) name, "vcpus-max-per-vm" ) == 0 ) {

        /*
         *  If there is a value for this tag, get it.
         */

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
        ret = get_tag_value( reader, &name, "vcpus-max-per-vm", &temp_value );

        /*
         *  Convert to megabytes.
         */

        if ( temp_value > 0 ) {

          systemMaxCPUsPerVM = atoi( temp_value );

          free( temp_value );
        }

        temp_value = NULL;
      }

      else if ( strcmp( (char *) name, "sra-si-overall-system-status") == 0)  {

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
  ret = get_tag_value( reader, &name, "sraSiOverallSystemStatus", &temp_value );

  if (temp_value != NULL) {

    if (strcmp( (char *) temp_value, "NOFAULTS") == 0) {
      systemState = SRASIOVERALLSYSTEMSTATUS_NOFAULTS;
    }

    else if (strcmp( (char *) temp_value, "SYSTEMFAULT") == 0) {
      systemState = SRASIOVERALLSYSTEMSTATUS_SYSTEMFAULT;
    }

    else if (strcmp( (char *) temp_value, "SYSTEMDOWN") == 0) {
      systemState = SRASIOVERALLSYSTEMSTATUS_SYSTEMDOWN;
    }

    free( temp_value);
    temp_value = NULL;

  }
      }


    } /* end while */

    /*
     *  Free the XML reader.
     */

    xmlFreeTextReader(reader);

    lastsupernovatime = time( 0 );

    return(1);
}

/*
 *  populate_host_scalars takes a previously fetched XML
 *  message that contains host info and sets scalar
 *  values based on that info.
 */

int populate_host_scalars( char *xml_ptr ) {

   xmlTextReaderPtr reader;

   int ret;
   int system_ok = 0;
   int system_warning = 0;
   int system_broken = 0;
   const xmlChar *name;
   char *temp_value;

   /*
    *  Free any elements already on the alert list.
    */
#if 0
   while ( alertTableList != NULL ) {

      alert_entry = alertTableList;
      if ( alert_entry->source != NULL )
         free ( alert_entry->source );
      if ( alert_entry->timestamp != NULL )
         free ( alert_entry->timestamp );
      if ( ( alert_entry->explain_text != NULL ) &&
           ( alert_entry->explain_text != blank ) )
         free ( alert_entry->explain_text);
      if ( alert_entry->type != NULL )
         free ( alert_entry->type );
      if ( ( alert_entry->SNMPtrap_OID != NULL ) &&
           ( alert_entry->SNMPtrap_OID != blank ) )
         free ( alert_entry->SNMPtrap_OID);

      alertTableList = alert_entry->next_ptr;
   }

   alert_entry = NULL;
#endif

  /*
   *  Access the XML message (already read into memory).
   */

   reader = xmlReaderForFile(XML_TEMP_FILE, 0, 0);
   if (reader == NULL)
      return(0);

   /*
    *  Loop through all the info in the XML message, a
    *  line at a time.
    */

   while ((ret = xmlTextReaderRead(reader)) == 1) {

      /*
       *  Get the name just read.
       */

      name = xmlTextReaderConstName(reader);

      /*
       * Check if DOH requires a login.
       * If it does, return DOH_NEED_LOGIN to login and retry.
       */
      ret = check_need_login(name, reader);
      if ( ret < 0 ) {
          xmlFreeTextReader(reader);
          return ret;
      }

      if ( strcmp( (char *) name, "standing-state" ) == 0 ) {

        /*
         *  We have a "standing-state" tag.
         *  Get its value if the tag is not empty.
         */

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;

        ret = get_tag_value( reader, &name, "standing-state", &temp_value );

        /*
         *  If we got a value, set the appropriate info in our new
         *  alert entry.
         */

        if ((ret == 1) && (temp_value != NULL)) {

            if ( strcmp(temp_value, "normal") == 0 ) {
                 system_ok = 1;
            }
            else if ( strcmp(temp_value, "warning") == 0 ) {
                 system_warning = 1;
              }
            else if ( strcmp(temp_value, "broken") == 0 ) {
                 system_broken = 1;
            }

            free(temp_value);

        }

        temp_value = NULL;
      }

    } /* end while */

    /*
     *  Free the XML reader.
     */

    xmlFreeTextReader(reader);

    lasthosttime = time( 0 );

    return(1);
}

/*
 *  populate_user_scalars takes a previously fetched XML
 *  message that contains user info and sets scalar
 *  values based on that info.
 */

int populate_user_scalars( char *xml_ptr ) {

   xmlTextReaderPtr reader;

   int ret;
   const xmlChar *name;

   /*
    *  Free any elements already on the alert list.
    */
#if 0
   while ( alertTableList != NULL ) {

      alert_entry = alertTableList;
      if ( alert_entry->source != NULL )
         free ( alert_entry->source );
      if ( alert_entry->timestamp != NULL )
         free ( alert_entry->timestamp );
      if ( ( alert_entry->explain_text != NULL ) &&
           ( alert_entry->explain_text != blank ) )
         free ( alert_entry->explain_text);
      if ( alert_entry->type != NULL )
         free ( alert_entry->type );
      if ( ( alert_entry->SNMPtrap_OID != NULL ) &&
           ( alert_entry->SNMPtrap_OID != blank ) )
         free ( alert_entry->SNMPtrap_OID);

      alertTableList = alert_entry->next_ptr;
   }

   alert_entry = NULL;
#endif

   /*
    *  Access the XML message (already read into memory).
    */

   reader = xmlReaderForFile(XML_TEMP_FILE, 0, 0);
   if (reader == NULL)
      return(0);

   /*
    *  Free old values.
    */

   if ( ( systemSerial != NULL ) && ( systemSerial != blank ) ) {

       free( systemSerial );
       systemSerial = blank;
   }

   if ( ( systemSiteID != NULL ) && ( systemSiteID != blank ) ) {

       free( systemSiteID );
       systemSiteID = blank;
   }


   /*
    *  Loop through all the info in the XML message, a
    *  line at a time.
    */

   while ((ret = xmlTextReaderRead(reader)) == 1) {

      /*
       *  Get the name just read.
       */

      name = xmlTextReaderConstName(reader);

      /*
       * Check if DOH requires a login.
       * If it does, return DOH_NEED_LOGIN to login and retry.
       */
      ret = check_need_login(name, reader);
      if ( ret < 0 ) {
          xmlFreeTextReader(reader);
          return ret;
      }

      if ( strcmp( (char *) name, "licenseKey" ) == 0 ) {

        /*
         *  We have a "management-ip" tag.
         *  Get its value if the tag is not empty.
         */

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;

        ret = get_tag_value( reader, &name, "licenseKey", &systemSerial );

        if ( systemSerial <= 0 ) systemSerial = blank;

        systemSiteID = malloc(strlen(systemSerial) + 1);
        strcpy(systemSiteID, systemSerial);
      }

    } /* end while */

    /*
     *  Free the XML reader.
     */

    xmlFreeTextReader(reader);

    lastusertime = time( 0 );

    return(1);
}

/*
 *  populate_storage_scalars takes a previously fetched XML
 *  message that contains storage info and sets scalar
 *  values based on that info.
 */

int populate_storage_scalars( char *xml_ptr ) {

   xmlTextReaderPtr reader;

   int ret;
   long long storage_int64 = 0;
   long long storage_used_int64 = 0;
   const xmlChar *name;
   char *temp_value;

   /*
    *  Access the XML message (already read into memory).
    */

   reader = xmlReaderForFile(XML_TEMP_FILE, 0, 0);
   if (reader == NULL)
      return(0);

   systemStorageUsed = 0;
   systemStorageFree = 0;
   systemStorageTotal = 0;

   /*
    *  Loop through all the info in the XML message, a
    *  line at a time.
    */

   while ((ret = xmlTextReaderRead(reader)) == 1) {

      /*
       *  Get the name just read.
       */

      name = xmlTextReaderConstName(reader);

      /*
       * Check if DOH requires a login.
       * If it does, return DOH_NEED_LOGIN to login and retry.
       */
      ret = check_need_login(name, reader);
      if ( ret < 0 ) {
          xmlFreeTextReader(reader);
          return ret;
      }

      if ( strcmp( (char *) name, "size" ) == 0 ) {

        /*
         *  We have a "size" tag.
         *  Get its value if the tag is not empty.
         */

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;

        ret = get_tag_value( reader, &name, "size", &temp_value );

        if ( temp_value > 0 ) {

          storage_int64 = storage_int64 + atoll( temp_value );
          free( temp_value );
        }

        temp_value = NULL;

      }

      else if ( strcmp( (char *) name, "size-used" ) == 0 ) {

        /*
         *  We have a "size-used" tag.
         *  Get its value if the tag is not empty.
         */

        if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;

        ret = get_tag_value( reader, &name, "size-used", &temp_value );

        if ( temp_value > 0 ) {

          storage_used_int64 = storage_used_int64 + atoll( temp_value );
          free( temp_value );
        }

        temp_value = NULL;

      }

    } /* end while */

    /*
     *  Free the XML reader.
     */

    xmlFreeTextReader(reader);

    systemStorageUsed = storage_used_int64 / 1048576;

    systemStorageTotal = storage_int64 / 1048576;

    systemStorageFree = systemStorageTotal - systemStorageUsed;
    if ( systemStorageFree < 0 ) systemStorageFree = 0;

    laststoragetime = time( 0 );

    return(1);
}

/*
 *  populate_alert_list takes a previously fetched XML
 *  message that contains alert log entries and creates
 *  a linked list out of them for SNMP queries.
 */

int populate_alert_list( char *xml_ptr ) {

   xmlTextReaderPtr reader;

   struct alertLogEntry *alert_entry = NULL;
   struct alertLogEntry *previous_loop_ptr = NULL;
   struct alertLogEntry *alert_loop_ptr = NULL;

   int ret;
   const xmlChar *name;
   xmlChar *read_value;
   char *found_logID = NULL;
   char *temp_value;

   char *found_alertID = NULL;
   char *found_source = NULL;
   char *found_SNMPtrapOID = NULL;

   /*
    *  We're only going to repopulate the cache every 30 seconds.
    */

   if ( ( time(0) - lastalerttime ) < 30 )
      return ( 1 );

   /*
    *  Free any elements already on the alert list.
    */

   while ( alertTableList != NULL ) {

      alert_entry = alertTableList;
      if ( alert_entry->source != NULL )
         free ( alert_entry->source );
      if ( alert_entry->timestamp != NULL )
         free ( alert_entry->timestamp );
      if ( ( alert_entry->explain_text != NULL ) &&
           ( alert_entry->explain_text != blank ) )
         free ( alert_entry->explain_text);
      if ( alert_entry->type != NULL )
         free ( alert_entry->type );
      if ( ( alert_entry->SNMPtrap_OID != NULL ) &&
           ( alert_entry->SNMPtrap_OID != blank ) )
         free ( alert_entry->SNMPtrap_OID);

      alertTableList = alert_entry->next_ptr;
      free( alert_entry );
   }

   alert_entry = NULL;
   in_alert = 0;

   /*
    *  Access the XML message (already read into memory).
    */

   reader = xmlReaderForFile(XML_TEMP_FILE, 0, 0);
   if (reader == NULL)
      return(0);

   /*
    *  Loop through all the info in the XML message, a
    *  line at a time.
    */

   while ((ret = xmlTextReaderRead(reader)) == 1) {

      /*
       *  Get the name just read.
       */

      name = xmlTextReaderConstName(reader);

      /*
       * Check if DOH requires a login.
       * If it does, return DOH_NEED_LOGIN to login and retry.
       */
      ret = check_need_login(name, reader);
      if ( ret < 0 ) {
          xmlFreeTextReader(reader);
          return ret;
      }

      /*
       *  If we got a name, read its associated value.
       */

      if ( name != NULL) {
          xmlTextReaderConstValue(reader);
      }

      /*
       *  If we see the tag "alert" and this isn't an
       *  empty element (i.e., it doesn't equal an empty
       *  tag such as "<iceCreamFlavor/>", then toggle the
       *  value of in_alert -- which indicates whether or
       *  not we're in an "alert" portion of the xml
       *  message.  Note that the first time we see it, we're
       *  entering an alert section (so we set in_alert
       *  to 1) and the next time we see it, we're exiting
       *  the section (so in_alert is 0).
       */

      if ( ( strcmp( (char *) name, "alert" ) == 0 ) &&
           ( xmlTextReaderIsEmptyElement(reader) == 0 ) ) {

        /*
         *  Are we in an "alert" section?
         */

        if ( in_alert ) {
           /*
            *  Yes; this means we're leaving an alert section.
            *  Did we extract an alert ID when we entered this
            *  section?
            */

           if ( found_alertID != NULL ) {

             /*
              *  We got an alert ID.  Loop through all of the
              *  alert elements that we've generated.
              */

             alert_loop_ptr = alertTableList;
             while ( alert_loop_ptr != NULL ) {

                /*
                 *  If this alert element is associated with the alert
                 *  ID of the alert section we're leaving, then update
                 *  the alert element's source field with the source
                 *  for this alert ID if it doesn't have one.
                 */

                if ( strcmp( alert_loop_ptr->alertID, found_alertID ) == 0 ) {
                   if ( alert_loop_ptr->source == NULL ) {
                      if ( found_source != NULL )
                         alert_loop_ptr->source = strdup( found_source );
                      else
                         alert_loop_ptr->source = strdup( " " );
                   }
                }
                alert_loop_ptr = alert_loop_ptr->next_ptr;
             }
           }

           /*
            *  Cleanup.
            */

           if ( found_alertID ) free( found_alertID );
           if ( found_SNMPtrapOID ) free( found_SNMPtrapOID );

           found_source = NULL;
           found_alertID = NULL;
           found_SNMPtrapOID = NULL;
           in_alert = 0;
        }
        else {

           /*
            *  We're entering an alert section.  Extract the alert
            *  ID from this tag.
            */

           found_alertID = (char *) xmlTextReaderGetAttribute( reader,
                                          (xmlChar *) "id");
           in_alert = 1;
        }
      }

      /*
       *  Similarly, see if we're entering or leaving a "log" section.
       */

      else if ( ( strcmp( (char *) name, "log" ) == 0 ) &&
           ( xmlTextReaderIsEmptyElement(reader) == 0 ) ) {

        /*
         *  If we're already in a "log" section and we see the "log" tag,
         *  that means that we're now leaving a log section.
         */

        if ( in_log ) {

           /*
            *  We want to add the alert log entry that we just
            *  finished generating to our list of entries.
            */

           alert_loop_ptr = alertTableList;

           /*
            *  If this is the first entry, just put it on the list!
            */

           if ( alertTableList == NULL ) {
             alertTableList = alert_entry;
           }

           /*
            *  There's at least one other entry here; we want to
            *  sort these by log ID, so find this entry's appropriate
            *  spot in the list.
            */

           else {
             int added = 0;
             previous_loop_ptr = NULL;

             /*
              *  Begin looping through the list.
              */

             while ( alert_loop_ptr != NULL ) {

               /*
                *  If the current entry's log ID is greater than
                *  the one in our new entry, we've found the
                *  place to insert it!
                */

               if ( strcmp( alert_loop_ptr->logID, alert_entry->logID ) > 0 ) {

                 /*
                  *  Set the new entry to point to the entry
                  *  already in the list that has the higher
                  *  log ID.
                  */

                 alert_entry->next_ptr = alert_loop_ptr;

                 /*
                  *  If we're inserting it at the beginning of the
                  *  list, point the list header to it.
                  */

                 if ( previous_loop_ptr == NULL ) {
                    alertTableList = alert_entry;
                    added = 1;
                 }

                 /*
                  *  If we're inserting into the middle of the list,
                  *  point the previous entry to our new entry.
                  */

                 else {
                    previous_loop_ptr->next_ptr = alert_entry;
                    added = 1;
                 }
                 break;
               }

               /*
                *  Update pointers for our next trip through the loop.
                */

               previous_loop_ptr = alert_loop_ptr;
               alert_loop_ptr = alert_loop_ptr->next_ptr;
             }

             /*
              *  If we haven't added the new entry yet, it goes on the
              *  end of the list!
              */

             if ( added == 0 ) {
               previous_loop_ptr->next_ptr = alert_entry;
             }
           }

           in_log = 0;
        }
        else {

           /*
            *  We're entering a log section; create a new entry.
            */

           alert_entry = calloc( 1, sizeof(struct alertLogEntry) );

           if ( found_SNMPtrapOID != NULL ) {
              alert_entry->SNMPtrap_OID = strdup(found_SNMPtrapOID);
           }

           /*
            *  The ID associated with this log entry is stored
            *  in the log tag with a value that begins with
            *  "log:o", which is followed by a series of digits.
            *  I'm told that the ":o" is guaranteed to be there,
            *  so that's what we'll assume!  Get to the digits
            *  and store the ID!
            */

           read_value = xmlTextReaderGetAttribute( reader,
                          (xmlChar *) "id");
           if ( read_value > 0 ) {

             /*
              *  Add 2 to the address of the ":o" to get to the
              *  digits.
              */

             found_logID = strstr((char*)read_value, ":o") + 2;

             /*
              *  If strstr() returned 0 (so, the above equation
              *  yields a value of 2), then that means we didn't
              *  find the ID; so check if this is the case before
              *  trying to access the ID.
              */

             if ( found_logID != (char *)2 ) {
               strcpy( alert_entry->logID, (char *) found_logID );
             }
           }

           /*
            *  If we got an alert ID when we entered the "alert"
            *  section (the "log" section lives in the "alert"
            *  section), then put that alert ID into our new entry.
            */

           if ( found_alertID != NULL ) {
               strcpy( alert_entry->alertID, found_alertID );
           }
           in_log = 1;
           if (read_value != NULL)
               xmlFree(read_value);
        }
      }

      /*
       *  There are callhome, ealert and snmp sections within
       *  the log section.  See if we're entering or leaving any
       *  of those and set the appropriate flags.
       */

      else if ( ( strcmp( (char *) name, "callhome" ) == 0 ) &&
           ( xmlTextReaderIsEmptyElement(reader) == 0 ) ) {
        if ( in_callhome ) in_callhome = 0;
        else in_callhome = 1;
      }

      else if ( ( strcmp( (char *) name, "ealert" ) == 0 ) &&
           ( xmlTextReaderIsEmptyElement(reader) == 0 ) ) {
        if ( in_ealert ) in_ealert = 0;
        else in_ealert = 1;
      }

      else if ( ( strcmp( (char *) name, "snmp" ) == 0 ) &&
           ( xmlTextReaderIsEmptyElement(reader) == 0 ) ) {
        if ( in_snmp ) in_snmp = 0;
        else in_snmp = 1;
      }

      /*
       *  If we're already in the callhome section (within a log section
       *  which is within an alert section), then we may find a "posted"
       *  which tells us whether or not a CallHome message was sent
       *  when this alert log was generated.
       */

      else if ( ( in_alert == 1 ) && ( in_log == 1 ) && ( in_callhome == 1 ) ) {

        if ( strcmp( (char *) name, "posted" ) == 0 ) {

          /*
           *  We have a "posted" tag within the callhome section.
           *  Get its value if the tag is not empty.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;

          ret = get_tag_value( reader, &name, "posted", &temp_value );

          /*
           *  If we got a value, set the appropriate info in our new
           *  alert entry.
           */

          if ((ret == 1) && (temp_value != NULL)) {
            if ( strncmp( temp_value, "true", 4 ) == 0 ) {
              alert_entry->callhome_sent = EVERRUNALERTCALLHOMESENT_TRUE;
            }
            else {
              alert_entry->callhome_sent = EVERRUNALERTCALLHOMESENT_FALSE;
            }

            free(temp_value);
            temp_value = NULL;
          }
        }

      }

      /*
       *  If we're already in the ealert section (within a log section
       *  which is within an alert section), then we may find a "posted"
       *  which tells us whether or not an eAlert message was sent
       *  when this alert log was generated.
       */

      else if ( ( in_alert == 1 ) && ( in_log == 1 ) && ( in_ealert == 1 ) ) {

        if ( strcmp( (char *) name, "posted" ) == 0 ) {

          /*
           *  We have a "posted" tag within the ealert section.
           *  Get its value if the tag is not empty.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "posted", &temp_value );

          /*
           *  If we got a value, set the appropriate info in our new
           *  alert entry.
           */

          if ((ret == 1) && (temp_value != NULL)) {
            if ( strncmp( temp_value, "true", 4 ) == 0 ) {
              alert_entry->eAlert_sent = EVERRUNALERTEALERTSENT_TRUE;
            }
            else {
              alert_entry->eAlert_sent = EVERRUNALERTEALERTSENT_FALSE;
            }

            free(temp_value);
            temp_value = NULL;
          }
        }

      }

      /*
       *  If we're already in the snmp section (within a log section
       *  which is within an alert section), then we may find a "posted"
       *  which tells us whether or not an SNMP trap was sent
       *  when this alert log was generated.
       */

      else if ( ( in_alert == 1 ) && ( in_log == 1 ) && ( in_snmp == 1 ) ) {

        if ( strcmp( (char *) name, "posted" ) == 0 ) {

          /*
           *  We have a "posted" tag within the snmp section.
           *  Get its value if the tag is not empty.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "posted", &temp_value );

          /*
           *  If we got a value, set the appropriate info in our new
           *  alert entry.
           */

          if ((ret == 1) && (temp_value != NULL)) {
            if ( strncmp( temp_value, "true", 4 ) == 0 ) {
              alert_entry->SNMPtrap_sent = EVERRUNALERTSNMPTRAPSENT_TRUE;
            }
            else {
              alert_entry->SNMPtrap_sent = EVERRUNALERTSNMPTRAPSENT_FALSE;
            }

            free(temp_value);
            temp_value = NULL;
          }
        }

      }

      /*
       *  If we are in the log section (but not in the callhome,
       *  ealert or snmp sections), then there are other tags
       *  for us to look for.
       */

      else if ( ( in_alert == 1 ) && ( in_log == 1 ) ) {

        /*
         *  The "time" tag...
         */

        if ( strcmp( (char *) name, "time" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "time", &alert_entry->timestamp );
        }

        /*
         *  The "explain-text" tag...
         */

        else if ( strcmp( (char *) name, "explain-text" ) == 0 ) {

          char *cr_found;

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) {
                 alert_entry->explain_text = blank;
                 continue;
          }

          ret = get_tag_value( reader, &name, "explain-text",
                 &alert_entry->explain_text );

          if (alert_entry->explain_text == NULL) {
             /*
              * snmpagent was crashing without this.  New DOH sends empty
              * explain-text as <explain-text></explain-text> as against
              * <explain-text/>. This does not pass the xmlTextReaderIsEmptyElement()
              * test above and get_tag_value() leaves this value is NULL.
              * But rest of the code here assumes this value to be non NULL.
              */
             alert_entry->explain_text = blank;
          }

          /*
           *  We want to remove the "__CR__" strings from this text (they
           *  are non-standard control mechanisms).
           *  Find each instance of the string and remove it by shifting
           *  the rest of the string 6 characters over (effectively
           *  wiping out the "__CR__" string.
           */

          while ( ( cr_found = strstr( alert_entry->explain_text, "__CR__")) ) {
             while ( *(cr_found+6) != '\0' ) {
               *cr_found = *(cr_found+6);
               cr_found++;
             }
          *cr_found = '\0';
          }

        }

        /*
         *  The "component" tag...
         */

        else if ( strcmp( (char *) name, "component" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) {
                 alert_entry->source = strdup(blank);
                 continue;
          }

          ret = get_tag_value( reader, &name, "component",
                 &alert_entry->source );
          found_source = alert_entry->source;

        }

        /*
         *  The "type" tag...
         */

        else if ( strcmp( (char *) name, "type" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "type", &alert_entry->type );
        }

        /*
         *  The "severity" tag...
         */

        else if ( strcmp( (char *) name, "severity" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "severity",
                      &temp_value );

          /*
           *  If we got a value, convert the string to an integer.
           */

          if ((ret == 1) && (temp_value != NULL)) {
            alert_entry->severity = copy_integer(temp_value);
            free(temp_value);
            temp_value = NULL;
          }
        }
      } /* end in alert and log */

      /*
       *  If we are in the alert section (but not in the log, callhome,
       *  ealert or snmp sections), then there is another tag
       *  for us to look for.
       */

      else if  ( in_alert == 1 ) {

        /*
         *  The "trapOID" tag...
         */

        if ( strcmp( (char *) name, "trapOID" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) {
                 found_SNMPtrapOID = strdup(blank);
                 continue;
          }

          ret = get_tag_value( reader, &name, "trapOID",
                 &found_SNMPtrapOID );

        }

      } /* end in alert */

    } /* end while */

    /*
     *  Free the XML reader.
     */

    xmlFreeTextReader(reader);

    lastalerttime = time( 0 );

    return(1);
}

/*
 *  populate_audit_list takes a previously fetched XML
 *  message that contains audit log entries and creates
 *  a linked list out of them for SNMP queries.
 */

int populate_audit_list( char *xml_ptr ) {

   xmlTextReaderPtr reader;

   struct auditLogEntry *audit_entry = NULL;
   struct auditLogEntry *previous_loop_ptr = NULL;
   struct auditLogEntry *audit_loop_ptr = NULL;

   int ret, status;
   const xmlChar *name;
   const xmlChar *read_value;
   char *temp_value;

   /*
    *  We're only going to repopulate the cache every 30 seconds.
    */

   if ( ( time(0) - lastaudittime ) < 30 )
      return ( 1 );

   /*
    *  Free any elements already on the audit list.
    */

   while( auditTableList != NULL ) {

     audit_entry = auditTableList;
     if ( audit_entry->index != NULL )
           free( audit_entry->index );
     if ( audit_entry->day != NULL )
           free( audit_entry->day );
     if ( audit_entry->timestamp != NULL )
           free( audit_entry->timestamp );
     if ( audit_entry->remoteuser != NULL )
           free( audit_entry->remoteuser );
     if ( audit_entry->description != NULL )
           free( audit_entry->description );

     auditTableList = audit_entry->next_ptr;

     free( audit_entry );
   }

   audit_entry = NULL;
   in_audit = 0;

   /*
    *  Access the XML message (already read into memory).
    */

   reader = xmlReaderForFile(XML_TEMP_FILE, 0, 0);
   if (reader == NULL)
      return(0);

   /*
    *  Loop through all the info in the XML message, a
    *  line at a time.
    */

   while ((ret = xmlTextReaderRead(reader)) == 1) {

      /*
       *  Get the name just read.
       */

      name = xmlTextReaderConstName(reader);

      /*
       * Check if DOH requires a login.
       * If it does, return DOH_NEED_LOGIN to login and retry.
       */
      ret = check_need_login(name, reader);
      if ( ret < 0 ) {
          xmlFreeTextReader(reader);
          return ret;
      }

      /*
       *  If we got a name, read its associated value.
       */

      if ( name != NULL) {
        read_value = xmlTextReaderConstValue(reader);
      }

      /*
       *  If we see the tag "audit" and this isn't an
       *  empty element (i.e., it doesn't equal an empty
       *  tag such as "<iceCreamFlavor/>", then toggle the
       *  value of in_audit -- which indicates whether or
       *  not we're in the "audit" portion of the XML
       *  message.  Note that the first time we see it, we're
       *  entering the audit section (so we set in_audit
       *  to 1) and the next time we see it, we're exiting
       *  the section (so in_audit is 0)
       */

      if ( ( strcmp( (char *) name, "audit" ) == 0 ) &&
           ( xmlTextReaderIsEmptyElement(reader) == 0 ) ) {

        /*
         *  If in_audit is set, then we're leaving the audit section.
         */

        if ( in_audit ) {

           /*  First, we need to make sure we got an index; otherwise,
            *  we're not going to use this audit entry.
            */

           if ( audit_entry->index == NULL ) {
              if ( audit_entry->day != NULL )
                 free( audit_entry->day );
              if ( audit_entry->timestamp != NULL )
                 free( audit_entry->timestamp );
              if ( audit_entry->remoteuser != NULL )
                 free( audit_entry->remoteuser );
              if ( audit_entry->description != NULL )
                 free( audit_entry->description );
              free(audit_entry);
              audit_entry = NULL;
           }

           /*
            *  We want to add our new audit log entry to the linked
            *  list of entries.  If the list is empty, just add the
            *  entry to the header!
            */
           else {
              audit_loop_ptr = auditTableList;
              if ( auditTableList == NULL ) {
                auditTableList = audit_entry;
              }

              /*
               *  We want the list to be sorted by the index, so loop through
               *  the list of audit entries, looking for this entry's spot
               *  in the list.
               */

              else {
                int added = 0;
                previous_loop_ptr = NULL;
                while ( audit_loop_ptr != NULL ) {

                  /*
                   *  If this list element has a larger index than our
                   *  new element, we've found our spot!
                   */

                  if ( strcmp( audit_loop_ptr->index, audit_entry->index ) > 0 ) {

                    /*
                     *  Have our new element point to the next element
                     *  in the list.
                     */

                    audit_entry->next_ptr = audit_loop_ptr;

                    /*
                     *  If we're to be at the beginning of the list,
                     *  set the header to point to our new entry.
                     */

                    if ( previous_loop_ptr == NULL ) {
                       auditTableList = audit_entry;
                       added = 1;
                    }

                    /*
                     *  If we're in the middle of the list, have the
                     *  previous element point to us.
                     */

                    else {
                       previous_loop_ptr->next_ptr = audit_entry;
                       added = 1;
                    }
                    break;
                  }

                  /*
                   *  Modify pointers for the next trip through the loop.
                   */

                  previous_loop_ptr = audit_loop_ptr;
                  audit_loop_ptr = audit_loop_ptr->next_ptr;
                }

                /*
                 *  If we didn't add the new element yet, put it at the
                 *  end of the list.
                 */

                if ( added == 0 ) {
                  previous_loop_ptr->next_ptr = audit_entry;
                }
              }

              in_audit = 0;

           }  /* end of having an index */
        } /* end of leaving an audit section */

        /*
         *  We're entering an audit section.
         */

        else {

           /*
            *  Create a new audit log entry.
            */

           audit_entry = calloc( 1, sizeof(struct auditLogEntry) );

           in_audit = 1;
        }
      }

      /*
       *  If we were already in an audit section, see if it's one of the
       *  tags within that section that we're interested in.
       */

      else if ( in_audit == 1 ) {

        /*
         *  The "auditIndex" tag...
         */

        if ( strcmp( (char *) name, "auditIndex" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "auditIndex",
                 &audit_entry->index );

        }

        /*
         *  The "day" tag...
         */

        else if ( strcmp( (char *) name, "day" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "time", &audit_entry->day );
        }

        /*
         *  The "time" tag...
         */

        else if ( strcmp( (char *) name, "time" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "time", &audit_entry->timestamp );
        }

        /*
         *  The "remotehost" tag...
         */

        else if ( strcmp( (char *) name, "remotehost" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "remotehost",
                 &temp_value );

          /*
           *  If we got a value, convert the string to an integer.
           */

          if ((ret == 1) && (temp_value != NULL)) {

             /*
              *  If DOH returns the string "null", then assume this
              *  is localhost (127.0.0.1).
              */

             if (strcmp( temp_value, "null" ) == 0 ) {
               free( temp_value );
               temp_value = strdup("127.0.0.1");
             }

             status = inet_aton( temp_value,
                         (struct in_addr *) &audit_entry->remotehost );

             /*
              *  If we can't make heads or tails of the IP address,
              *  use localhost.
              */

             if ( status == 0 ) {
               free( temp_value );
               temp_value = strdup("127.0.0.1");
               status = inet_aton( temp_value,
                         (struct in_addr *) &audit_entry->remotehost );

             }

             free(temp_value);
             temp_value = NULL;
          }
        }

        /*
         *  The "remoteuser" tag...
         */

        else if ( strcmp( (char *) name, "remoteuser" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "remoteuser",
                 &audit_entry->remoteuser );

        }

        /*
         *  The "description" tag...
         */

        else if ( strcmp( (char *) name, "description" ) == 0 ) {

          /*
           *  If there is a value for this tag, get it.
           */

          if ( xmlTextReaderIsEmptyElement(reader) == 1 ) continue;
          ret = get_tag_value( reader, &name, "description",
                 &audit_entry->description );
        }
      }

    } /* end while */

    /*
     *  Free the XML reader.
     */

    xmlFreeTextReader(reader);

    lastaudittime = time( 0 );

    return(1);
}

/*
 *  The following routine was automatically generated by mib2c and
 *  is unused.
 */

void
stratus_free_undoInfo(void *vptr)
{
    struct undoInfo *ui = vptr;
    if (!ui)
        return;
    SNMP_FREE(ui->ptr);
    SNMP_FREE(ui);
}

/*
 *  fetch_doh_information gets the various scalars that we're expecting
 *  from doh.  We store these values so that we don't have to tap DOH
 *  every time they're asked for.
 */

void fetch_doh_information() {

char *xml_ptr;
int status, request;
struct alertLogEntry *alert_entry;
struct auditLogEntry *audit_entry;
int sequence[] = {
    DOH_SUPERNOVA,
    DOH_SYSTEM_STATUS,
    DOH_SERIAL_NUMBER,
    DOH_STORAGE_USED,
    DOH_ALERT_TABLE,
    DOH_AUDIT_TABLE
};
const int sequence_len = sizeof(sequence)/sizeof(sequence[0]);

   for ( request = 0; request < sequence_len; request++ ) {
       status = process_doh_request( sequence[request], &xml_ptr );
       if ( status == -1 )
           continue;
       /* Only log in to DOH when it tells us we have to. */
       if ( status == DOH_NEED_LOGIN ) {
           process_doh_request( DOH_LOGOUT, &xml_ptr );
           status = process_doh_request( DOH_LOGIN, &xml_ptr );
           if ( status == -1 ) {
               printf("Unable to log in to DOH! Some SNMP results may not be updated.\n");
               break;
           }
           status = process_doh_request( sequence[request], &xml_ptr);
       }
   }

   /*
    *  Time to update the global values.  Get the mutex controlling this.
    */

   status = pthread_mutex_lock( &doh_mutex );

   /*
    *  Only update the values if we got the mutex.
    */

   if ( status == 0 ) {

  doh_ipAddress = ipAddress;
        if ( ( doh_systemName != NULL ) && ( doh_systemName != blank ) )
           free( doh_systemName );
  doh_systemName = systemName;
        systemName = NULL;
        doh_systemMemory = systemMemory;
        doh_systemCPUs = systemCPUs;
        doh_systemUsedCPUs = systemUsedCPUs;
        doh_systemMaxCPUsPerVM = systemMaxCPUsPerVM;
        doh_systemState = systemState;
        if ( ( doh_systemSerial != NULL ) && ( doh_systemSerial != blank ) )
           free( doh_systemSerial );
        doh_systemSerial = systemSerial;
        systemSerial = NULL;
        if  ( ( doh_systemSiteID != NULL ) && ( doh_systemSiteID != blank ) )
           free( doh_systemSiteID );
        doh_systemSiteID = systemSiteID;
        systemSiteID = NULL;
        doh_systemStorageUsed = systemStorageUsed;
        doh_systemStorageFree = systemStorageFree;
        doh_systemStorageTotal = systemStorageTotal;

        /*
         *  Free any elements already on the alert list.
         */

        while ( doh_alertTableList != NULL ) {

           alert_entry = doh_alertTableList;
           if ( alert_entry->source != NULL )
              free ( alert_entry->source );
           if ( alert_entry->timestamp != NULL )
              free ( alert_entry->timestamp );
           if ( ( alert_entry->explain_text != NULL ) &&
                ( alert_entry->explain_text != blank ) )
              free ( alert_entry->explain_text);
           if ( alert_entry->type != NULL )
              free ( alert_entry->type );
           if ( ( alert_entry->SNMPtrap_OID != NULL ) &&
                ( alert_entry->SNMPtrap_OID != blank ) )
              free ( alert_entry->SNMPtrap_OID);

           doh_alertTableList = alert_entry->next_ptr;
           free( alert_entry );
        }

        doh_alertTableList = alertTableList;
        doh_alertTableFlag = 1;
        alertTableList = NULL;

        /*
         *  Free any elements already on the audit list.
         */

        while ( doh_auditTableList != NULL ) {

          audit_entry = doh_auditTableList;
          if ( audit_entry->index != NULL )
                free( audit_entry->index );
          if ( audit_entry->day != NULL )
                free( audit_entry->day );
          if ( audit_entry->timestamp != NULL )
                free( audit_entry->timestamp );
          if ( audit_entry->remoteuser != NULL )
                free( audit_entry->remoteuser );
          if ( audit_entry->description != NULL )
                free( audit_entry->description );

          doh_auditTableList = audit_entry->next_ptr;

          free( audit_entry );
        }

        doh_auditTableList = auditTableList;
        doh_auditTableFlag = 1;
        auditTableList = NULL;

        /*
         *  Unlock the mutex.
         */

        status = pthread_mutex_unlock( &doh_mutex );
   }
}

/*
 * Thread to update DOH values every 60 seconds.
 */

void *doh_update_thread( void * null_arg ) {

   while ( 1 ) {

     sleep( 60 );
     fetch_doh_information( );
     fflush(stdout);
   }
}

/*
 *  Initialize the everRunAlertTable table by defining its
 *  contents and how it's structured.
 */

void
initialize_table_everRunAlertTable(void)
{
    static oid      everRunAlertTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 10 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;
    netsnmp_variable_list *var;

    /*
     *  Create the table registration information structures.
     */

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("everRunAlertTable",
                                                     everRunAlertTable_handler,
                                                     everRunAlertTable_oid,
                                                     OID_LENGTH
                                                     (everRunAlertTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo) {
        printf("failed to init alert table\n");
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_everRunAlertTable");
        return; /** Serious error. */
    }

    /*
     *  Indicate that we have one index and it's an integer.
     */

    var = calloc(sizeof(*var), 1);
    var->type = ASN_INTEGER;
    table_info->indexes = var;
    table_info->number_indexes = 1;

    /*
     *  Setting up the table's definition.
     */

    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,  0);

    /*
     *  Define the minimum and maximum accessible columns.  This
     *  optimizes retrival.
     */

    table_info->min_column = 1;
    table_info->max_column = 10;

    /*
     *  Iterator access routines
     */

    iinfo->get_first_data_point = everRunAlertTable_get_first_data_point;
    iinfo->get_next_data_point = everRunAlertTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = everRunAlertTable_context_convert_function;
    iinfo->free_data_context = everRunAlertTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = everRunAlertTable_loop_free;
#endif
    iinfo->free_loop_context_at_end = everRunAlertTable_loop_free;

    /*
     *  Tie the two structures together.
     */

    iinfo->table_reginfo = table_info;

    /*
     *  Registering the table with the master agent.
     */

    DEBUGMSGTL(("initialize_table_everRunAlertTable",
                "Registering table everRunAlertTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/*
 *  Initialize the everRunAuditTable table by defining its contents
 *  and how it's structured.
 */

void
initialize_table_everRunAuditTable(void)
{
    static oid      everRunAuditTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 12 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;
    netsnmp_variable_list *var;

    /*
     *  Create the table registration information structures.
     */

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("everRunAuditTable",
                                                     everRunAuditTable_handler,
                                                     everRunAuditTable_oid,
                                                     OID_LENGTH
                                                     (everRunAuditTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_everRunAuditTable");
        return; /** Serious error. */
    }

    /*
     *  Indicate that we have one index and it's an integer.
     */

    var = calloc(sizeof(*var), 1);
    var->type = ASN_INTEGER;
    table_info->indexes = var;
    table_info->number_indexes = 1;

    /*
     *  Setting up the table's definition.
     */

    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER, 0);

    /*
     *  Define the minimum and maximum accessible columns.  This
     *  optimizes retrival.
     */

    table_info->min_column = 1;
    table_info->max_column = 5;

    /*
     * Iterator access routines
     */

    iinfo->get_first_data_point = everRunAuditTable_get_first_data_point;
    iinfo->get_next_data_point = everRunAuditTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = everRunAuditTable_context_convert_function;
    iinfo->free_data_context = everRunAuditTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = everRunAuditTable_loop_free;
#endif
    iinfo->free_loop_context_at_end = everRunAuditTable_loop_free;

    /*
     *  Tie the two structures together.
     */

    iinfo->table_reginfo = table_info;

    /*
     *  Registering the table with the master agent.
     */

    DEBUGMSGTL(("initialize_table_everRunAuditTable",
                "Registering table everRunAuditTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}



/*
 *  Initializes the stratus module.
 */

void
init_stratus(void)
{
    static oid      sraAgentMibFamily_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 102, 1 };
    static oid      sraAgentMibRevision_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 102, 2 };
    static oid      sraSiSystemType_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 103, 1 };
    static oid      sraSiManufacturer_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 103, 2 };
    static oid      sraSiModel_oid[] = { 1, 3, 6, 1, 4, 1, 458, 103, 3 };
    static oid      sraSiOverallSystemStatus_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 103, 4 };
    static oid      sraSiSystemName_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 103, 5 };
    static oid      sraSiSystemSerialNumber_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 103, 6 };
    static oid      sraSiSiteID_oid[] = { 1, 3, 6, 1, 4, 1, 458, 103, 7 };
    static oid      sraSiCpuFamily_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 103, 8 };
    static oid      sraSiOsType_oid[] = { 1, 3, 6, 1, 4, 1, 458, 103, 9 };
    static oid      everRunAvailableVirtualMemory_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 1 };
    static oid      everRunVirtualCPUsTotal_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 2 };
    static oid      everRunVirtualCPUsInUse_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 3 };
    static oid      everRunVirtualCPUsMaxPerVM_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 4 };
/*    static oid      everRunVirtualCPUsPercentageUsed_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 5 }; */
    static oid      everRunStorageTotal_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 5 };
    static oid      everRunStorageUsed_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 6 };
/*    static oid      everRunStorageUsedByManagement_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 8 }; */
    static oid      everRunStorageFree_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 7 };
/*    static oid      everRunDiskReadBytes_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 10 };
    static oid      everRunDiskWriteBytes_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 11 }; */
    static oid      everRunIPAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 8 };
/*    static oid      everRunNetworkReadBytes_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 13 };
    static oid      everRunNetworkWriteBytes_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 14 }; */
    static oid      everRunAlertNumber_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 9 };
    static oid      everRunAuditNumber_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 1, 11 };
/*    static oid      everRunTrapDescription_oid[] =
        { 1, 3, 6, 1, 4, 1, 458, 115, 3, 1 };
*/

    DEBUGMSGTL(("stratus", "Initializing\n"));

    systemSerial = blank;
    systemSiteID = blank;

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraAgentMibFamily", handle_sraAgentMibFamily,
                             sraAgentMibFamily_oid,
                             OID_LENGTH(sraAgentMibFamily_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraAgentMibRevision",
                             handle_sraAgentMibRevision,
                             sraAgentMibRevision_oid,
                             OID_LENGTH(sraAgentMibRevision_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraSiSystemType", handle_sraSiSystemType,
                             sraSiSystemType_oid,
                             OID_LENGTH(sraSiSystemType_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraSiManufacturer", handle_sraSiManufacturer,
                             sraSiManufacturer_oid,
                             OID_LENGTH(sraSiManufacturer_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraSiModel", handle_sraSiModel,
                             sraSiModel_oid, OID_LENGTH(sraSiModel_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraSiOverallSystemStatus",
                             handle_sraSiOverallSystemStatus,
                             sraSiOverallSystemStatus_oid,
                             OID_LENGTH(sraSiOverallSystemStatus_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraSiSystemName", handle_sraSiSystemName,
                             sraSiSystemName_oid,
                             OID_LENGTH(sraSiSystemName_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraSiSystemSerialNumber",
                             handle_sraSiSystemSerialNumber,
                             sraSiSystemSerialNumber_oid,
                             OID_LENGTH(sraSiSystemSerialNumber_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraSiSiteID", handle_sraSiSiteID,
                             sraSiSiteID_oid, OID_LENGTH(sraSiSiteID_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraSiCpuFamily", handle_sraSiCpuFamily,
                             sraSiCpuFamily_oid,
                             OID_LENGTH(sraSiCpuFamily_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sraSiOsType", handle_sraSiOsType,
                             sraSiOsType_oid, OID_LENGTH(sraSiOsType_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunAvailableVirtualMemory",
                             handle_everRunAvailableVirtualMemory,
                             everRunAvailableVirtualMemory_oid,
                             OID_LENGTH(everRunAvailableVirtualMemory_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunVirtualCPUsTotal",
                             handle_everRunVirtualCPUsTotal,
                             everRunVirtualCPUsTotal_oid,
                             OID_LENGTH(everRunVirtualCPUsTotal_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunVirtualCPUsInUse",
                             handle_everRunVirtualCPUsInUse,
                             everRunVirtualCPUsInUse_oid,
                             OID_LENGTH(everRunVirtualCPUsInUse_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunVirtualCPUsMaxPerVM",
                             handle_everRunVirtualCPUsMaxPerVM,
                             everRunVirtualCPUsMaxPerVM_oid,
                             OID_LENGTH(everRunVirtualCPUsMaxPerVM_oid),
                             HANDLER_CAN_RONLY));
/*    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunVirtualCPUsPercentageUsed",
                             handle_everRunVirtualCPUsPercentageUsed,
                             everRunVirtualCPUsPercentageUsed_oid,
                             OID_LENGTH
                             (everRunVirtualCPUsPercentageUsed_oid),
                             HANDLER_CAN_RONLY)); */
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunStorageTotal",
                             handle_everRunStorageTotal,
                             everRunStorageTotal_oid,
                             OID_LENGTH(everRunStorageTotal_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunStorageUsed", handle_everRunStorageUsed,
                             everRunStorageUsed_oid,
                             OID_LENGTH(everRunStorageUsed_oid),
                             HANDLER_CAN_RONLY));
/*    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunStorageUsedByManagement",
                             handle_everRunStorageUsedByManagement,
                             everRunStorageUsedByManagement_oid,
                             OID_LENGTH(everRunStorageUsedByManagement_oid),
                             HANDLER_CAN_RONLY)); */
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunStorageFree", handle_everRunStorageFree,
                             everRunStorageFree_oid,
                             OID_LENGTH(everRunStorageFree_oid),
                             HANDLER_CAN_RONLY));
/*    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunDiskReadBytes",
                             handle_everRunDiskReadBytes,
                             everRunDiskReadBytes_oid,
                             OID_LENGTH(everRunDiskReadBytes_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunDiskWriteBytes",
                             handle_everRunDiskWriteBytes,
                             everRunDiskWriteBytes_oid,
                             OID_LENGTH(everRunDiskWriteBytes_oid),
                             HANDLER_CAN_RONLY)); */
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunIPAddress",
                             handle_everRunIPAddress,
                             everRunIPAddress_oid,
                             OID_LENGTH(everRunIPAddress_oid),
                             HANDLER_CAN_RONLY));
/*    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunNetworkReadBytes",
                             handle_everRunNetworkReadBytes,
                             everRunNetworkReadBytes_oid,
                             OID_LENGTH(everRunNetworkReadBytes_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunNetworkWriteBytes",
                             handle_everRunNetworkWriteBytes,
                             everRunNetworkWriteBytes_oid,
                             OID_LENGTH(everRunNetworkWriteBytes_oid),
                             HANDLER_CAN_RONLY)); */
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunAlertNumber", handle_everRunAlertNumber,
                             everRunAlertNumber_oid,
                             OID_LENGTH(everRunAlertNumber_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunAuditNumber", handle_everRunAuditNumber,
                             everRunAuditNumber_oid,
                             OID_LENGTH(everRunAuditNumber_oid),
                             HANDLER_CAN_RONLY));
#if 0
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("everRunTrapDescription",
                             handle_everRunTrapDescription,
                             everRunTrapDescription_oid,
                             OID_LENGTH(everRunTrapDescription_oid),
                             HANDLER_CAN_RONLY));
#endif

  /*
   *  Here we initialize all the tables we're planning on supporting.
   */

  initialize_table_everRunAlertTable();
  initialize_table_everRunAuditTable();

}

int
handle_sraAgentMibFamily(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int family = SRAAGENTMIBFAMILY_EVERRUN;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &family, sizeof(family) );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_sraAgentMibFamily\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sraAgentMibRevision(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int revision = SRAAGENTMIBREVISION_REV01;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &revision, sizeof(revision) );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_sraAgentMibRevision\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sraSiSystemType(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OBJECT_ID,
                                 (u_char *) sraProductIdEverRun_oid,
         sizeof(sraProductIdEverRun_oid));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sraSiSystemType\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sraSiManufacturer(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    char *manufacturer = "Stratus Technologies";

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) manufacturer,
                                 strlen(manufacturer));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_sraSiManufacturer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sraSiModel(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    char *model = "AV100";

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) model, strlen(model));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sraSiModel\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sraSiOverallSystemStatus(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */
    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {

            int localSystemState = SRASIOVERALLSYSTEMSTATUS_SYSTEMDOWN;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *) &localSystemState,
                                     sizeof(localSystemState));
        }
        else {
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *) &doh_systemState,
                                     sizeof(doh_systemState));
            status = pthread_mutex_unlock( &doh_mutex );
        }
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_sraSiOverallSystemStatus\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sraSiSystemName(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

     case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( ( status != 0 ) || ( doh_systemName == NULL ) ) {
           snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                    (u_char *) " ", strlen (" "));
        }
        else {

           snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                    (u_char *) doh_systemName, strlen(doh_systemName));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sraSiSystemName\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sraSiSystemSerialNumber(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( ( status != 0 ) || ( doh_systemSerial == NULL ) ) {
           snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                    (u_char *) " ", strlen (" "));
        }
        else {

           snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                    (u_char *) doh_systemSerial, strlen(doh_systemSerial));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_sraSiSystemSerialNumber\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sraSiSiteID(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( ( status != 0 ) || ( doh_systemSiteID == NULL ) ) {
           snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                    (u_char *) " ", strlen (" "));
        }
        else {
           snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                    (u_char *) doh_systemSiteID, strlen(doh_systemSiteID));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sraSiSiteID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sraSiCpuFamily(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int family = SRASICPUFAMILY_IA32;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &family, sizeof(family));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sraSiCpuFamily\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sraSiOsType(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int os_type = SRASIOSTYPE_EVERRUN;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &os_type, sizeof(os_type));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sraSiOsType\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_everRunAvailableVirtualMemory(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {
           int localSystemMemory = 0;
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &localSystemMemory, sizeof(localSystemMemory));
        }
        else {
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &doh_systemMemory, sizeof(doh_systemMemory));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunAvailableVirtualMemory\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_everRunVirtualCPUsTotal(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {
           int localSystemCPUs = 0;
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &localSystemCPUs, sizeof(localSystemCPUs));
        }
        else {
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &doh_systemCPUs, sizeof(doh_systemCPUs));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunVirtualCPUsTotal\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_everRunVirtualCPUsInUse(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {
           int localSystemUsedCPUs = 0;
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &localSystemUsedCPUs, sizeof(localSystemUsedCPUs));
        }
        else {
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &doh_systemUsedCPUs, sizeof(doh_systemUsedCPUs));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunVirtualCPUsInUse\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_everRunVirtualCPUsMaxPerVM(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {
           int localMaxCPUsPerVM = 0;
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &localMaxCPUsPerVM, sizeof(localMaxCPUsPerVM));
        }
        else {

           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &doh_systemMaxCPUsPerVM, sizeof(doh_systemMaxCPUsPerVM));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunVirtualCPUsMaxPerVM\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if 0
int
handle_everRunVirtualCPUsPercentageUsed(netsnmp_mib_handler *handler,
                                       netsnmp_handler_registration
                                       *reginfo,
                                       netsnmp_agent_request_info *reqinfo,
                                       netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int percent = 0;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &percent, sizeof(percent));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunVirtualCPUsPercentageUsed\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

int
handle_everRunStorageTotal(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

#if 0
    char *storage;
    int occurrences = 1;

        while (1) {

           /*
            *  Get each instance of storage on the system and
            *  add them together.
            */

           storage = get_value_from_xml(xml_ptr, strlen(xml_ptr),
                                  "size-total", occurrences);

           if ( storage <= 0 ) break;

           printf("storage total is %s\n", storage);
           storage_int64 = storage_int64 + atoi(storage);

           occurrences++;
        }
#endif
        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {
           int localSystemStorageTotal = 0;
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &localSystemStorageTotal, sizeof(localSystemStorageTotal));
        }
        else {
           /*
            *  Convert to megabytes.
            */

           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &doh_systemStorageTotal,
                                    sizeof(doh_systemStorageTotal));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunStorageTotal\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_everRunStorageUsed(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {
           int localSystemStorageUsed = 0;
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &localSystemStorageUsed, sizeof(localSystemStorageUsed));
        }
        else {
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &doh_systemStorageUsed,
                                    sizeof(doh_systemStorageUsed));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunStorageUsed\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if 0
int
handle_everRunStorageUsedByManagement(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int storage = 0;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &storage, sizeof(storage));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunStorageUsedByManagement\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

int
handle_everRunStorageFree(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {
           int localSystemStorageFree = 0;
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &localSystemStorageFree, sizeof(localSystemStorageFree));
        }
        else {
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &doh_systemStorageFree,
                                    sizeof(doh_systemStorageFree));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunStorageFree\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if 0
int
handle_everRunDiskReadBytes(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int readbytes = 0;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &readbytes, sizeof(readbytes));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunDiskReadBytes\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_everRunDiskWriteBytes(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int writebytes = 0;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &writebytes, sizeof(writebytes));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunDiskWriteBytes\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

int
handle_everRunIPAddress(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {
           struct in_addr localIpAddress;
           memset( &localIpAddress, 0, sizeof(localIpAddress) );
           snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                    (u_char *) &localIpAddress, 4);
        }
        else {
           snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                    (u_char *) &doh_ipAddress, 4);
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunDiskWriteBytes\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if 0
int
handle_everRunNetworkReadBytes(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int readbytes = 0;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &readbytes, sizeof(readbytes));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunNetworkReadBytes\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_everRunNetworkWriteBytes(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int writebytes = 0;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &writebytes, sizeof(writebytes));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunNetworkWriteBytes\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

int
handle_everRunAlertNumber(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;
    int number = 0;
    struct alertLogEntry *alert_entry;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {
           int localAlertNumber = 0;
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &localAlertNumber, sizeof(localAlertNumber));
        }
        else {
           if ( doh_alertTableList == NULL )
              alert_entry = alertTableWalkList;
           else
              alert_entry = doh_alertTableList;

           /*
            *  The number of entries in our linked list of alert logs is
            *  equal to the number of entries in the SNMP table.
            */

           while ( alert_entry != NULL ) {
             number++;
             alert_entry = alert_entry->next_ptr;
           }

           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &number, sizeof(number));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunAlertNumber\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_everRunAuditNumber(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    int status;
    int number = 0;
    struct auditLogEntry *audit_entry;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * An instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        /*
         *  Get the doh mutex.
         */

        status = pthread_mutex_lock( &doh_mutex );

        if ( status != 0 ) {
           int localAuditNumber = 0;
           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &localAuditNumber, sizeof(localAuditNumber));
        }
        else {
           if ( doh_auditTableList == NULL )
              audit_entry = auditTableWalkList;
           else
              audit_entry = doh_auditTableList;

           /*
            *  The number of entries in our linked list of audit logs is
            *  equal to the number of entries in the SNMP table.
            */

           while ( audit_entry != NULL ) {
             number++;
             audit_entry = audit_entry->next_ptr;
           }

           snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    (u_char *) &number, sizeof(number));
           status = pthread_mutex_unlock( &doh_mutex );
        }

        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunAuditNumber\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 *  Handles requests for the everRunAlertTable table, if anything
 *  else needs to be done
 */

int
everRunAlertTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
/*    struct commitInfo *ci = NULL; */

    void           *data_context = NULL;

    oid            *suffix;
    size_t          suffix_len;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_EVERRUNALERTINDEX:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAlertIndex(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNALERTSEVERITY:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAlertSeverity(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNALERTTYPE:
                {
                    char           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAlertType(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;


            case COLUMN_EVERRUNALERTSOURCE:
                {
                    char           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAlertSource(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;


            case COLUMN_EVERRUNALERTDATETIME:
                {
                    char           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAlertDateTime(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNALERTCALLHOMESENT:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAlertCallHomeSent(data_context,
                                                    &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNALERTEALERTSENT:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAlertEAlertSent(data_context,
                                                  &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNALERTSNMPTRAPSENT:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAlertSNMPTrapSent(data_context,
                                                    &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNALERTINFORMATION:
                {
                    char           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAlertInformation(data_context,
                                                   &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNALERTSNMPTRAPOID:
                {
                    char           *retval;
                    oid            *return_oid;
                    oid            *returned_oid = NULL;
                    size_t          retval_len = 0;
                    size_t          return_oid_len = 0;
                    retval =
                        get_everRunAlertSNMPTrapOID(data_context,
                                                   &retval_len);
                    if (retval) {
                        return_oid = calloc(retval_len*sizeof(oid), 1);
                        return_oid_len = retval_len*sizeof(oid);
                        if ( return_oid != NULL ) {
                          returned_oid = snmp_parse_oid( retval, return_oid,
                                                     &return_oid_len );
                          snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                                 (u_char *) return_oid,
                                                 return_oid_len*sizeof(oid));
                          free(return_oid);
                        }
                    }
                }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in everRunAlertTable_handler: unknown column\n");
            }
            break;

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in everRunAlertTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/*
 *  Handles requests for the everRunAuditTable table, if anything
 *  else needs to be done
 */

int
everRunAuditTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
 /*   struct commitInfo *ci = NULL; */

    void           *data_context = NULL;

    oid            *suffix;
    size_t          suffix_len;

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /** column and row index encoded portion */
    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_EVERRUNAUDITINDEX:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAuditIndex(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNAUDITDATETIME:
                {
                    char           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAuditDateTime(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNAUDITUSERNAME:
                {
                    char           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAuditUsername(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNAUDITORIGINATINGHOST:
                {
                    char  *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAuditOriginatingHost(data_context,
                                                       &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_IPADDRESS,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            case COLUMN_EVERRUNAUDITACTION:
                {
                    char           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_everRunAuditAction(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 (const u_char *) retval,
                                                 retval_len);
                }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in everRunAuditTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in everRunAuditTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

#if 0
int
handle_everRunTrapDescription(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     *  Read the config file to see if we're accepting requests.
     */

    get_config_from_xml();

    /*
     *  If we're disabled, return.
     */

    if ( enable_requests == 0 )
       return (SNMP_ERR_GENERR);

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_everRunTrapDescription\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if 0
int  send_everRunTrapId#_trap( void )
{
    netsnmp_variable_list *var_list = NULL;
    oid everRunTrapId#_oid[] = { 1,3,6,1,4,1,458,115,2,0 };

    /*
     * Set the snmpTrapOid.0 value
     */

    snmp_varlist_add_variable(&var_list,
            snmptrap_oid, OID_LENGTH(snmptrap_oid),
            ASN_OBJECT_ID, everRunTrapId#_oid, sizeof(everRunTrapId#_oid));

    /*
     * Add any extra (optional) objects here
     */
    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap(var_list);
    snmp_free_varbind(var_list);
    return SNMP_ERR_NOERROR;
}
#endif

/** returns the first data point within the everRunAlertTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
everRunAlertTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    int status;

    /*
     *  Get the doh mutex.
     */

    status = pthread_mutex_lock( &doh_mutex );

    if ( status != 0 ) {
      *my_loop_context = NULL;
      *my_data_context = NULL;
      return NULL;
     }

    if ( alertTableWalkList == NULL ) {
       alertTableWalkList = doh_alertTableList;
       doh_alertTableList = NULL;
       doh_alertTableFlag = 0;
    }

    if ( alertTableWalkList == NULL ) {
      status = pthread_mutex_unlock( &doh_mutex );
      *my_loop_context = NULL;
      *my_data_context = NULL;
      return NULL;
    }

    status = pthread_mutex_unlock( &doh_mutex );

    *my_loop_context = alertTableWalkList;
    *my_data_context = alertTableWalkList;

    vptr = put_index_data;
    /*vptr->name = everRunAlertTableIndex_oid;
    vptr->name_length = 13; */


    indexdata = atoi(alertTableWalkList->logID);

    snmp_set_var_value( vptr, (u_char *) &indexdata, sizeof(indexdata));

    return put_index_data;
}

/** functionally the same as everRunAlertTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
everRunAlertTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    struct alertLogEntry *alertTableEntry;
    int status;

    /*
     *  Get the doh mutex.
     */

    status = pthread_mutex_lock( &doh_mutex );

    if ( status != 0 ) {
      *my_loop_context = NULL;
      *my_data_context = NULL;
      return NULL;
     }

    alertTableEntry = *my_loop_context;
    alertTableEntry = alertTableEntry->next_ptr;

    if ( alertTableEntry == NULL ) {

      status = pthread_mutex_unlock( &doh_mutex );
      return( NULL );
    }

    *my_loop_context = alertTableEntry;
    *my_data_context = alertTableEntry;

    vptr = put_index_data;

    indexdata = atoi(alertTableEntry->logID);
    status = pthread_mutex_unlock( &doh_mutex );
    snmp_set_var_value( vptr, (u_char *) &indexdata, sizeof(indexdata));

    return put_index_data;
}

void everRunAlertTable_loop_free(void *my_loop_context,
                               netsnmp_iterator_info *mydata)
{
    int status;
    struct alertLogEntry *alert_entry = NULL;

    /*
     *  Get the doh mutex.
     */

    status = pthread_mutex_lock( &doh_mutex );

    if ( status == 0 ) {

      if ( ( doh_alertTableList == NULL ) &&
           ( doh_alertTableFlag == 0 ) ) {
         doh_alertTableList = alertTableWalkList;
         doh_alertTableFlag = 1;
      }
      else {

         /*
          *  Free any elements already on the alert list.
          */

         while ( alertTableWalkList != NULL ) {

            alert_entry = alertTableWalkList;
            if ( alert_entry->source != NULL )
               free ( alert_entry->source );
            if ( alert_entry->timestamp != NULL )
               free ( alert_entry->timestamp );
            if ( ( alert_entry->explain_text != NULL ) &&
                 ( alert_entry->explain_text != blank ) )
               free ( alert_entry->explain_text);
            if ( alert_entry->type != NULL )
               free ( alert_entry->type );
            if ( ( alert_entry->SNMPtrap_OID != NULL ) &&
                 ( alert_entry->SNMPtrap_OID != blank ) )
               free ( alert_entry->SNMPtrap_OID);

            alertTableWalkList = alert_entry->next_ptr;
            free( alert_entry );
         }
      }

      alertTableWalkList = NULL;
      status = pthread_mutex_unlock( &doh_mutex );
    }
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void           *
everRunAlertTable_create_data_context(netsnmp_variable_list * index_data,
                                     int column)
{
    printf("getting everRun alert create data context\n");
    return alertTablePtr;                /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
everRunAlertTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*
     */
    printf("getting everRun alert commit row\n");

    /*
     * return no errors.  And there shouldn't be any!!!  Ever!!!  You
     * should have checked the values long before this.
     */
    return SNMP_ERR_NOERROR;
}


/*
 * User-defined data access functions (per column) for data in table everRunAlertTable
 */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the everRunAlertIndex column and set
         ret_len to its proper size in bytes. */
long           *
get_everRunAlertIndex(void *data_context, size_t *ret_len)
{
    struct alertLogEntry *alert_entry = NULL;

    if ( data_context == NULL )
      return NULL;

    alert_entry = data_context;
    alertIndex = atoi(alert_entry->logID);
    *ret_len = sizeof(alertIndex);
    return alertIndexPtr;
}

/** XXX: return a data pointer to the data for the everRunAlertSeverity column and set
         ret_len to its proper size in bytes. */
long           *
get_everRunAlertSeverity(void *data_context, size_t *ret_len)
{
    struct alertLogEntry *alert_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    alert_entry = data_context;
    alertSeverity = alert_entry->severity;
    *ret_len = sizeof(alertSeverity);
    return alertSeverityPtr;
}

/** XXX: return a data pointer to the data for the everRunAlertType column and set
         ret_len to its proper size in bytes. */
char           *
get_everRunAlertType(void *data_context, size_t *ret_len)
{
    struct alertLogEntry *alert_entry = NULL;

    if ( data_context == NULL )
      return NULL;

    alert_entry = data_context;
    alertTypePtr = alert_entry->type;
    *ret_len = strlen(alertTypePtr);
    return alertTypePtr;
}

/** XXX: return a data pointer to the data for the everRunAlertType column and set
         ret_len to its proper size in bytes. */
char           *
get_everRunAlertSource(void *data_context, size_t *ret_len)
{
    struct alertLogEntry *alert_entry = NULL;

    if ( data_context == NULL )
      return NULL;

    alert_entry = data_context;
    alertSourcePtr = alert_entry->source;
    *ret_len = strlen(alertSourcePtr);
    return alertSourcePtr;
}
/** XXX: return a data pointer to the data for the everRunAlertDateTime column and set
         ret_len to its proper size in bytes. */
char           *
get_everRunAlertDateTime(void *data_context, size_t *ret_len)
{
    struct alertLogEntry *alert_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    alert_entry = data_context;
    alertDateTimePtr = alert_entry->timestamp;
    *ret_len = strlen(alertDateTimePtr);
    return alertDateTimePtr;
}

/** XXX: return a data pointer to the data for the everRunAlertCallHomeSent column and set
         ret_len to its proper size in bytes. */
long           *
get_everRunAlertCallHomeSent(void *data_context, size_t *ret_len)
{
    struct alertLogEntry *alert_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    alert_entry = data_context;
    alertCallHomeSent = alert_entry->callhome_sent;
    *ret_len = sizeof(alertCallHomeSent);
    return alertCallHomeSentPtr;
}

/** XXX: return a data pointer to the data for the everRunAlertEAlertSent column and set
         ret_len to its proper size in bytes. */
long           *
get_everRunAlertEAlertSent(void *data_context, size_t *ret_len)
{
    struct alertLogEntry *alert_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    alert_entry = data_context;
    alertEAlertSent = alert_entry->eAlert_sent;
    *ret_len = sizeof(alertEAlertSent);
    return alertEAlertSentPtr;
}

/** XXX: return a data pointer to the data for the everRunAlertSNMPTrapSent column and set
         ret_len to its proper size in bytes. */
long           *
get_everRunAlertSNMPTrapSent(void *data_context, size_t *ret_len)
{
    struct alertLogEntry *alert_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    alert_entry = data_context;
    alertSNMPTrapSent = alert_entry->SNMPtrap_sent;
    if ( alertSNMPTrapSent == 0 ) alertSNMPTrapSent = 1;
    *ret_len = sizeof(alertSNMPTrapSent);
    return alertSNMPTrapSentPtr;
}

/** XXX: return a data pointer to the data for the everRunAlertInformation column and set
         ret_len to its proper size in bytes. */
char           *
get_everRunAlertInformation(void *data_context, size_t *ret_len)
{
    struct alertLogEntry *alert_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    alert_entry = data_context;
    alertInformationPtr = alert_entry->explain_text;
    *ret_len = strlen(alertInformationPtr);
    return alertInformationPtr;
}

/** XXX: return a data pointer to the data for the everRunAlertSNMPTrapOID column and set
         ret_len to its proper size in bytes. */
char           *
get_everRunAlertSNMPTrapOID(void *data_context, size_t *ret_len)
{
    struct alertLogEntry *alert_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    alert_entry = data_context;
    alertSNMPTrapOIDPtr = alert_entry->SNMPtrap_OID;
    if ( alertSNMPTrapOIDPtr == NULL )
      alertSNMPTrapOIDPtr = blank;
    *ret_len = strlen(alertSNMPTrapOIDPtr);
    return alertSNMPTrapOIDPtr;
}


/** returns the first data point within the everRunAuditTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
everRunAuditTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    int status;

    /*
     *  Get the doh mutex.
     */

    status = pthread_mutex_lock( &doh_mutex );

    if ( status != 0 ) {
      *my_loop_context = NULL;
      *my_data_context = NULL;
      return NULL;
     }

    if ( auditTableWalkList == NULL ) {
       auditTableWalkList = doh_auditTableList;
       doh_auditTableFlag = 0;
       doh_auditTableList = NULL;
    }

    if ( auditTableWalkList == NULL ) {
      status = pthread_mutex_unlock( &doh_mutex );
      *my_loop_context = NULL;
      *my_data_context = NULL;
      return NULL;
    }

    status = pthread_mutex_unlock( &doh_mutex );

    *my_loop_context = auditTableWalkList;
    *my_data_context = auditTableWalkList;

    vptr = put_index_data;
    /*vptr->name = everRunAlertTableIndex_oid;
    vptr->name_length = 13; */


    indexdata = atoi(auditTableWalkList->index);
    snmp_set_var_value( vptr, (u_char *) &indexdata, sizeof(indexdata));

    return put_index_data;
}

/** functionally the same as everRunAuditTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
everRunAuditTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    struct auditLogEntry *auditTableEntry;
    int status;

    /*
     *  Get the doh mutex.
     */

    status = pthread_mutex_lock( &doh_mutex );

    if ( status != 0 ) {
      *my_loop_context = NULL;
      *my_data_context = NULL;
      return NULL;
     }

    auditTableEntry = *my_loop_context;
    auditTableEntry = auditTableEntry->next_ptr;

    if ( auditTableEntry == NULL ) {
      status = pthread_mutex_unlock( &doh_mutex );
      return( NULL );
    }

    *my_loop_context = auditTableEntry;
    *my_data_context = auditTableEntry;

    vptr = put_index_data;

    indexdata = atoi(auditTableEntry->index);
    status = pthread_mutex_unlock( &doh_mutex );
    snmp_set_var_value( vptr, (u_char *) &indexdata, sizeof(indexdata));

    return put_index_data;
}

void everRunAuditTable_loop_free(void *my_loop_context,
                               netsnmp_iterator_info *mydata)
{
    int status;
    struct auditLogEntry *audit_entry = NULL;

    /*
     *  Get the doh mutex.
     */

    status = pthread_mutex_lock( &doh_mutex );

    if ( status == 0 ) {

      if ( ( doh_auditTableList == NULL ) &&
           ( doh_auditTableFlag == 0 ) ) {

         doh_auditTableList = auditTableWalkList;
         doh_auditTableFlag = 1;
      }
      else {

         /*
          *  Free any elements already on the audit list.
          */

         while ( auditTableWalkList != NULL ) {

            audit_entry = auditTableWalkList;
            if ( audit_entry->index != NULL )
               free( audit_entry->index );
            if ( audit_entry->day != NULL )
               free( audit_entry->day );
            if ( audit_entry->timestamp != NULL )
               free( audit_entry->timestamp );
            if ( audit_entry->remoteuser != NULL )
               free( audit_entry->remoteuser );
            if ( audit_entry->description != NULL )
               free( audit_entry->description );

            auditTableWalkList = audit_entry->next_ptr;
            free( audit_entry );
         }
      }

      auditTableWalkList = NULL;
      status = pthread_mutex_unlock( &doh_mutex );
    }
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void           *
everRunAuditTable_create_data_context(netsnmp_variable_list * index_data,
                                     int column)
{
    printf("getting everRun audit create data context\n");
    return auditTablePtr;                /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
everRunAuditTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*
     */
    printf("getting everRun audit commit row\n");

    /*
     * return no errors.  And there shouldn't be any!!!  Ever!!!  You
     * should have checked the values long before this.
     */
    return SNMP_ERR_NOERROR;
}


/*
 * User-defined data access functions (per column) for data in table everRunAuditTable
 */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the everRunAuditIndex column and set
         ret_len to its proper size in bytes. */
long           *
get_everRunAuditIndex(void *data_context, size_t *ret_len)
{
    struct auditLogEntry *audit_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    audit_entry = data_context;
    auditIndex = atoi(audit_entry->index);
    *ret_len = sizeof(auditIndex);
    return auditIndexPtr;
}

/** XXX: return a data pointer to the data for the everRunAuditDateTime column and set
         ret_len to its proper size in bytes. */
char           *
get_everRunAuditDateTime(void *data_context, size_t *ret_len)
{
    struct auditLogEntry *audit_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    audit_entry = data_context;
    strcpy(auditDateTime, audit_entry->day);
    strcat(auditDateTime, " ");
    strcat(auditDateTime, audit_entry->timestamp);
    auditDateTimePtr = auditDateTime;
    *ret_len = strlen(auditDateTimePtr);
    return auditDateTimePtr;
}

/** XXX: return a data pointer to the data for the everRunAuditUsername column and set
         ret_len to its proper size in bytes. */
char           *
get_everRunAuditUsername(void *data_context, size_t *ret_len)
{
    struct auditLogEntry *audit_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    audit_entry = data_context;
    auditUsernamePtr = audit_entry->remoteuser;
    *ret_len = strlen(auditUsernamePtr);
    return auditUsernamePtr;
}

/** XXX: return a data pointer to the data for the everRunAuditOriginatingHost column and set
         ret_len to its proper size in bytes. */
char *get_everRunAuditOriginatingHost(void *data_context, size_t *ret_len)
{
    struct auditLogEntry *audit_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    audit_entry = data_context;
    auditOriginatingHostPtr = (char *) &audit_entry->remotehost;
    *ret_len = 4;
    return auditOriginatingHostPtr;
}

/** XXX: return a data pointer to the data for the everRunAuditAction column and set
         ret_len to its proper size in bytes. */
char           *
get_everRunAuditAction(void *data_context, size_t *ret_len)
{
    struct auditLogEntry *audit_entry = NULL;

    if ( data_context == NULL )
       return NULL;

    audit_entry = data_context;
    auditActionPtr = audit_entry->description;
    *ret_len = strlen(auditActionPtr) - 1;
    return auditActionPtr;
}

/** Read the hidden user's password from /shared/creds. */
int get_credentials(char *username, char *password,
                    size_t userlen, size_t passlen,
                    time_t *last_check)
{
    FILE *file = NULL;
    size_t readcount = 0;
  int i;
    struct stat fileinfo;

    if (last_check != NULL) {
        if (stat("/shared/creds/root", &fileinfo) != 0)
            goto err_credentials;

        if (fileinfo.st_mtime < *last_check)
            goto ok_credentials;
    }

    if (username == NULL || password == NULL)
        goto err_credentials;

    if (passlen < 1)
        goto err_credentials;

    if (userlen < strlen("root"))
        goto err_credentials;
    else
        strcpy(username, "root");

    file = fopen("/shared/creds/root", "r");
    if (file == NULL)
        goto err_credentials;

    readcount = fread(password, sizeof(char), passlen, file);
    if (readcount < 1)
        goto err_credentials;
  for(i = 0; i < (int)readcount; i++)
  {
    password[i] = password[i] ^ salt2[i % salt2len];
    password[i] = password[i] ^ secret[i % secretlen];
    password[i] = password[i] ^ salt1[i % salt1len];
  }
    password[passlen-1] = '\0';

    if (last_check != NULL)
        *last_check = fileinfo.st_mtime;

ok_credentials:
    if (file != NULL)
        fclose(file);
    return 0;

err_credentials:
    if (file != NULL)
        fclose(file);
    if (username != NULL)
        username[0] = '\0';
    if (password != NULL)
        password[0] = '\0';
    return -1;
}

/*
 * Copy the session ID cookie from the HTTP header so it gets used for
 * requests that do not require a login. This should prevent quite a bit
 * of useless xenapi logging.
 */
void check_session_id(char *http_response)
{
#define csid_length 32
#define csid_expected 1
#define csid_strsub(x) #x
#define csid_str(x) csid_strsub(x)

    regex_t regex;
    regoff_t id_start, id_end;
    regmatch_t matches[csid_expected];
    char *pattern = "[[:xdigit:]]\\{" csid_str(csid_length) "\\}";
    char *cookie_ptr;
    char *cookie_end;
    char *cookie_str;
    size_t cookie_len;

    do {
        cookie_ptr = strstr(http_response, "Set-Cookie");
        if (cookie_ptr == NULL)
            break;

        cookie_end = strstr(cookie_ptr, "\r\n");
        if (cookie_end == NULL)
            break;

        cookie_len = cookie_end-cookie_ptr;
        cookie_str = (char *)malloc(cookie_len*sizeof(char));
        if (cookie_str == NULL)
            break;

        strncpy(cookie_str, cookie_ptr, cookie_len);
        cookie_str[cookie_len-1] = '\0';

        if (regcomp(&regex, pattern, 0) != 0) {
            free(cookie_str);
            break;
        }

        if (regexec(&regex, cookie_str, csid_expected, matches, 0) != 0) {
            free(cookie_str);
            regfree(&regex);
            break;
        }

        id_start = matches[0].rm_so;
        id_end = matches[0].rm_eo;

        if (id_end-id_start != csid_length) {
            free(cookie_str);
            regfree(&regex);
            break;
        }

        strncpy(current_session_id, cookie_str+id_start, csid_length);
        current_session_id[csid_length] = '\0';
        free(cookie_str);
        regfree(&regex);

        printf("Using unauthenticated session ID: %s\n", current_session_id);
    } while (0);
}

int process_doh_request( int request, char **xml_ptr ){

int i, status;
char *xml_request = NULL;
char *tmp_ptr;
FILE *filefd;
char *http_string = NULL;

char *http_login_string = "POST /doh/ HTTP/1.0\r\nHost: localhost\r\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11\r\nAccept: text/javascript, text/html, application/xml, text/xml, */*\r\nAccept-Language: en-us,en;q=0.5\r\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\nKeep-Alive: 300\r\nConnection: close\r\nContent-Type: text/xml\r\nContent-Length: %d\r\nPragma: no-cache\r\nCache-Control: no-cache\r\n\r\n";

char *http_loggedin_string = "POST /doh/ HTTP/1.0\r\nHost: localhost\r\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11\r\nAccept: text/javascript, text/html, application/xml, text/xml, */*\r\nAccept-Language: en-us,en;q=0.5\r\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\nKeep-Alive: 300\r\nConnection: close\r\nContent-Type: text/xml\r\nContent-Length: %d\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nCookie: JSESSIONID=%s\r\n\r\n";

/*
char *http_string = "POST /doh/ HTTP/1.1\r\nUser-Agent: everRun SNMP\r\nHost: localhost\r\nContent-Type: text/xml\r\nContent-Length: %d\r\nSet-Cookie: PHPSESSID=%s\r\nConnection: close\r\n\r\n";
*/
/*
char *http_string = "POST /doh/?PHPSESSID=%s HTTP/1.1\r\nUser-Agent: everRun SNMP\r\nHost: localhost\r\nContent-Type: text/xml\r\nContent-Length: %d\r\nConnection: close\r\n\r\n";
*/

/*
 *  First, let's see if we already have the info cached.
 */

switch( request ) {

  case DOH_LOGIN:

    if (get_credentials(login_username, login_password, sizeof(login_username),
                        sizeof(login_password), &lastcredtime) != 0) {
        printf("Can't read credentials for hidden user!\n");
        return( -1 );
    }
    sprintf(login_request, xml_login_request, login_username, login_password);
    break;

  case DOH_LOGOUT:

    if ( current_session_id[0] == '\0' )
        return (0);
    break;

  case DOH_SUPERNOVA:
  case DOH_SYSTEM_NAME:
  case DOH_AVAIL_VIRTUAL_MEMORY:
  case DOH_VIRTUAL_CPU_TOTAL:
  case DOH_VIRTUAL_CPU_IN_USE:
  case DOH_VIRTUAL_CPUS_MAX_PER_VM:

    if ( ( time( 0 ) - lastsupernovatime ) < 30 )
        return( 0 );
    break;

  case DOH_SYSTEM_STATUS:

    if ( ( time( 0 ) - lasthosttime ) < 30 )
        return( 0 );
    break;

  case DOH_SERIAL_NUMBER:
  case DOH_SITE_ID:

    if ( ( time( 0 ) - lastusertime ) < 30 )
        return( 0 );
    break;

  case DOH_STORAGE_USED:
  case DOH_STORAGE_FREE:
  case DOH_STORAGE_TOTAL:

    if ( ( time( 0 ) - laststoragetime ) < 30 )
        return( 0 );
    break;

  case DOH_ALERT_TABLE:

    if ( ( time( 0 ) - lastalerttime ) < 30 )
        return( 0 );
    break;

  case DOH_AUDIT_TABLE:

    if ( ( time( 0 ) - lastaudittime ) < 30 )
        return( 0 );
    break;
}

  /*
   *  Create a socket.
   */

  doh_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

  if ( doh_sock < 0 ) {
     printf("Can't open socket for DOH\n");
     return(-1);
  }

  /*
   *  Open a connection to DOH.  THe HTTP port is 80.
   */

  http_hostent = gethostbyname("localhost");
  if ( http_hostent == NULL ) {
       printf("Can't get localhost information\n");
       close(doh_sock);
       return(-1);
  }

  memset( &doh_address, 0, sizeof(doh_address) );
  doh_address.sin_addr = *(struct in_addr*) http_hostent->h_addr_list[0];
  doh_address.sin_family = AF_INET;
  doh_address.sin_port = htons(80);

  status = connect( doh_sock, (struct sockaddr *) &doh_address,
                    sizeof(doh_address) );

  if ( status < 0 ) {
     printf("Can't connect to HTTP port\n");
     close(doh_sock);
     return (-1);
  }


  switch(request) {

  case DOH_LOGIN:
    http_string = http_login_string;
    xml_request = login_request;
    break;

  case DOH_LOGOUT:
    http_string = http_loggedin_string;
    xml_request = xml_logout_request;
    break;

  case DOH_SUPERNOVA:
  case DOH_SYSTEM_NAME:
  case DOH_AVAIL_VIRTUAL_MEMORY:
  case DOH_VIRTUAL_CPU_TOTAL:
  case DOH_VIRTUAL_CPU_IN_USE:
  case DOH_VIRTUAL_CPUS_MAX_PER_VM:
    http_string = http_loggedin_string;
    xml_request = xml_supernova_request;
    break;

  case DOH_SYSTEM_STATUS:
    http_string = http_loggedin_string;
    xml_request = xml_host_request;
    break;

  case DOH_SERIAL_NUMBER:
  case DOH_SITE_ID:
    http_string = http_loggedin_string;
    xml_request = xml_user_request;
    break;

  case DOH_STORAGE_USED:
  case DOH_STORAGE_FREE:
  case DOH_STORAGE_TOTAL:
    http_string = http_loggedin_string;
    xml_request = xml_sharedstorage_request;
    break;

  case DOH_ALERT_TABLE:
    http_string = http_loggedin_string;
    xml_request = xml_alert_table_request;
    break;

  case DOH_AUDIT_TABLE:
    http_string = http_loggedin_string;
    xml_request = xml_audit_table_request;
    break;
  }

  xml_string_length = strlen(xml_request);


  http_string_length = sprintf(http_request, http_string,
                             xml_string_length, current_session_id);


  strcat(http_request, xml_request);

  /* printf("Request:\n%s\n", http_request); */

  sent_bytes = send (doh_sock, http_request, strlen(http_request), 0);

  if ( sent_bytes < 0 ) {
     printf("Can't send to HTTP port\n");
     close(doh_sock);
     return(-1);
  }

  /*
   * Create the buffer if we don't have one.
   */

  if ( http_response == NULL ) {
    http_response = malloc(INIT_HTTP_RESPONSE_SIZE);
    if ( http_response > 0 ) {
      http_response_size = INIT_HTTP_RESPONSE_SIZE;
    }
    else {
      http_response_size = 0;
      http_response = NULL;
      close(doh_sock);
      return(-1);
    }
  }

  memset(http_response, 0, http_response_size);
  received_bytes = http_response_size;

  /*
   *  We're going to write the entire message to a file.
   */

  filefd = fopen(XML_TEMP_FILE, "w+");

  if ( filefd < 0 ) {
    printf("Warning - Unable to open /etc/snmp/tempxml\n");
    close(doh_sock);
    return(-1);
  }

  /*
   *  Read the data.  The MSG_WAITALL flag makes us wait until the full
   *  message is received or the sender disconnects.  We're in a while loop
   *  so that we can read the message in manageable chunks.
   */

  while ( received_bytes > 0 ) {

    received_bytes = recv(doh_sock, http_response, http_response_size, MSG_WAITALL);

    if ( received_bytes < 0 ) {
       printf("Can't receive from HTTP port\n");
       close(doh_sock);
       return(-1);
    }

    /*
     * Save the session ID so DOH doesn't have to create one for every request.
     * This will prevent a good deal of unhelpful xenapi log messages.
     */

    check_session_id(http_response);

    tmp_ptr = http_response;

    /*
     *  The XML part of the message begins with <?xml, so only start
     *  processing the message from that point.
     */

    *xml_ptr = strstr(http_response, "<?xml");

    if (*xml_ptr != NULL) {
      tmp_ptr = *xml_ptr;
      received_bytes = received_bytes - (*xml_ptr - http_response);
    }

    /*
     *  We're going to write the message to a file.  The XML parser
     *  doesn't like unprintable characters, so filter those out.
     */

    for ( i = 0; i < received_bytes; i++ ) {

      if ( isprint(tmp_ptr[i]) ) {
        fputc( tmp_ptr[i], filefd );
      }
    }
  }

  fclose(filefd);

  close(doh_sock);

switch(request) {

case DOH_LOGIN:
  status = populate_login_scalars( *xml_ptr );
  break;

case DOH_LOGOUT:
  memset(current_session_id, '\0', sizeof(current_session_id));
  break;

case DOH_SUPERNOVA:
case DOH_SYSTEM_NAME:
case DOH_AVAIL_VIRTUAL_MEMORY:
case DOH_VIRTUAL_CPU_TOTAL:
case DOH_VIRTUAL_CPU_IN_USE:
case DOH_VIRTUAL_CPUS_MAX_PER_VM:
  status = populate_supernova_scalars( *xml_ptr );
  break;

case DOH_SYSTEM_STATUS:
  status = populate_host_scalars( *xml_ptr );
  break;

case DOH_SERIAL_NUMBER:
case DOH_SITE_ID:
  status = populate_user_scalars( *xml_ptr );
  break;

case DOH_STORAGE_USED:
case DOH_STORAGE_FREE:
case DOH_STORAGE_TOTAL:
  status = populate_storage_scalars( *xml_ptr );
  break;

case DOH_ALERT_TABLE:
  status = populate_alert_list( *xml_ptr );
  break;

case DOH_AUDIT_TABLE:
  status = populate_audit_list( *xml_ptr );
  break;
}

if ( status == 0 )
    status = DOH_RESPONSE;
else if ( status != DOH_NEED_LOGIN )
    status = DOH_SUCCESS;

return(status);

}

void alarm_callback(unsigned int reg, void *clientarg)
{
}

int main(argc, argv)
     int argc;
     char * argv[];
{

pthread_t doh_thread;
int status;
// int command_option;
// int option_index = 0;
pid_t pid = -1;
FILE *fd;

/*
static oid snmpPeerTreeOid[] = {1, 3, 6, 1, 4, 1, 458};
netsnmp_handler_registration *handler_registration;
*/

fd = freopen("/var/opt/ft/log/smd/everrunsnmpagent.log", "a", stdout);
fd = freopen("/var/opt/ft/log/smd/everrunsnmpagent.log", "a", stderr);

struct rlimit core_dump;
core_dump.rlim_cur = RLIM_INFINITY;
core_dump.rlim_max = RLIM_INFINITY;
if ( setrlimit(RLIMIT_CORE, &core_dump) < 0 ) {
    printf("could not enable core dumps\n");
}

// fork the process to make a pseudo-daemon process
//while (pid < 0) {
  pid = fork();
  if (pid < 0)  {
    printf("forking everrunsnmpagent failed\n");
  }

  if (pid > 0) { exit(EXIT_SUCCESS); }
//}

/*
 *  Get the PID of the process.
 */

pid = getpid();

/*
 *  Open a file and write the PID to it.
 */

fd = fopen("/var/run/ft/everrunsnmpagent.pid", "w+");

if ( fd != 0 ) {

  status = fprintf(fd, "%d",pid);
  fclose(fd);
}

#if 0
/*
 *  Parse command-line arguments.
 */

while (1) {
  command_option = getopt_long (argc, argv, "TS:P:?h",
                                long_options, &option_index);
  if ( command_option == -1 ) break;

  switch (command_option) {

    case 0:
      do {
        switch (option_index) {
          case 0:
            priv0_address = strdup(optarg);
        }
      } while(0);
  }
}
#endif

/*
 *  Do our logging to stderr.
 */


snmp_enable_stderrlog();

/*
 *  Indicate we're an agent and set the agentX port for the cluster
 *  master agent (705).
 */

netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_ROLE, 1);
/* netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
                            NETSNMP_DS_AGENT_X_SOCKET, "localhost:705");
*/

/*
 *  Initialize TCP/IP.
 */

SOCK_STARTUP;

/*
 *  Set keep_running; this will be set to zero if we want to exit.
 */

keep_running = 1;

/*
 *  Set signal handlers that will set keep_running to zero on an
 *  interruption.
 */

signal(SIGTERM, stop_server);
signal(SIGINT, stop_server);

/*
 *  Do the initial fetch of specific values from SMD.
 */

fetch_doh_information();

/*
 *  Start the thread to refresh DOH information periodically.
 */

status = pthread_create( &doh_thread, NULL, &doh_update_thread, NULL );

/*
 *  Initialize the everRun subagent.
 */

status = init_agent("everrunsnmpagent");

if ( status != SNMP_ERR_NOERROR ) {
  printf("Can't initialize as a subagent; exiting...\n");
  exit(0);
}

/*
 *  Register the handler for each incoming PDU.  The priority of -1
 *  indicates that our request is to override other agent requests
 *  for the same SNMP messages; in other words, whatever SNMP message
 *  comes into the cluster master agent, we want that message to be
 *  routed to us.
 */

#if 0
while (keep_running) {

   handler_registration =
     netsnmp_create_handler_registration
                         ("msgHandler", message_handler, snmpPeerTreeOid, 7,
                          HANDLER_CAN_RONLY);
   handler_registration->priority = -1;

   status = netsnmp_register_handler(handler_registration);

   if ( status == SNMP_ERR_NOERROR ) break;

   printf("waiting for cluster master agent\n");
   sleep(30);

}
#endif

init_stratus();

/*
 *  Set up an alarm handler just so that we can detect disconnects.
 */

status = snmp_alarm_register(30, SA_REPEAT, alarm_callback, NULL);

/*
 *  Initialize SNMP.
 */

init_snmp("everRun-snmpagent");

/*
status = process_doh_request( DOH_VERSION, &xml_ptr );
if ( status != 0 ) {
   printf("Could not talk to DOH for version; continuing...\n");
}
*/

#if 0
/*
 *  Open a connection to DOH.
 */

doh_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

if ( doh_sock < 0 ) {
  printf("Can't open socket for DOH; exiting...\n");
  exit(0);
}

{
/*
 *  Open a connection to DOH.  THe HTTP port is 80.
 */

http_hostent = gethostbyname("localhost");
if ( http_hostent == NULL ) {
  close(doh_sock);
  printf("Can't get localhost information; exiting...\n");
  exit(0);
}

memset( &doh_address, 0, sizeof(doh_address) );
doh_address.sin_addr = *(struct in_addr*) http_hostent->h_addr_list[0];
doh_address.sin_family = AF_INET;
doh_address.sin_port = htons(80);

status = connect( doh_sock, &doh_address, sizeof(doh_address) );

if ( status < 0 ) {
  close(doh_sock);
  printf("Can't connect to HTTP port; exiting...\n");
  exit(0);
}

printf("socket is %d\n", doh_sock);

xml_string_length = strlen(xml_request);

printf("xml string length is %d\n", xml_string_length);

http_string_length = sprintf(http_request,
   "POST /doh/ HTTP/1.1\r\nUser-Agent: everRun SNMP\r\nHost: localhost\r\nContent-Type: text/xml\r\nContent-Length: %d\r\nConnection: close\r\n\r\n" , xml_string_length);
/*
   "Content-Type: text/xml; charset=utf-8\r\n"
   "Content-Length: %d\r\n\r\n", xml_string_length);
*/

printf("http string length is %d\n", http_string_length);

strcat(http_request, xml_request);

printf("Request:\n%s\n", http_request);

sent_bytes = send (doh_sock, http_request, strlen(http_request), 0);

if ( sent_bytes < 0 ) {
  close(doh_sock);
  printf("Can't send to HTTP port; exiting...\n");
  exit(0);
}

printf("bytes sent is %d\n", sent_bytes);

received_bytes = recv(doh_sock, http_response, 1024, 0);

if ( received_bytes <= 0 ) {
  close(doh_sock);
  perror("Can't receive from HTTP port; exiting...\n");
  exit(0);
}

close(doh_sock);

printf("bytes received is %d\n", received_bytes);

printf("Response:\n%s\n", http_response);
#endif


/*
 *  In a loop, process incoming SNMP requests.
 */

while(keep_running) {
  agent_check_and_process(1);
}

snmp_shutdown("everRun-snmpagent");
SOCK_CLEANUP;

exit(0);

}
